<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-yu.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-yu.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="ChatGPT, C++, SLAM, Programmer" />










<meta name="description" content="于小咸，专注 C++ 和 人工智能的 算法工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="于小咸的日志">
<meta property="og:url" content="https://blog.yu-xiaoxian.me/page/2/index.html">
<meta property="og:site_name" content="于小咸的日志">
<meta property="og:description" content="于小咸，专注 C++ 和 人工智能的 算法工程师">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yu Xiaoxian">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.yu-xiaoxian.me/page/2/"/>





  <title>于小咸的日志</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'G-RMLFJCZC88', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?607044d6c57f45fed7816b9a44592d85";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 7.1.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">于小咸的日志</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.yu-xiaoxian.me/2020/05/26/wiki/EffectivCpp-tip01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于小咸的日志">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/26/wiki/EffectivCpp-tip01/" itemprop="url">C++是一个语言联邦</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-26T21:43:16+00:00">
                2020-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wiki/" itemprop="url" rel="index">
                    <span itemprop="name">Wiki</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>点击链接查看更多C++ 技巧 ：<a href="https://blog.yu-xiaoxian.me/2019/05/03/wiki/EffectivCpp/">Effective C++</a></p>
<hr>
<p>C++ 是一个强大的编程语言，但他的风格并不统一，这是由于C++是一个语言联邦，由以下四部分组成，每部分都有自己的特点。</p>
<ul>
<li>C语言：</li>
<li>面向对象的C++：包括类，类的派生和继承</li>
<li>模板元编程的C++：模板元编程是图灵完全的语言，也有自己的风格特点</li>
<li>STL库：STL是官方提供的标准库</li>
</ul>
<h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h2><p>C++ 最早就是 C 语言的预编译器，兼容了C语言的所有特性，然而C语言的类型转换不够安全，C++中做了安全的类型转换，导致C++和C的特性有一定的差别，在编程时要区分是C 还是 C++</p>
<h2 id="面向对象的C"><a href="#面向对象的C" class="headerlink" title="面向对象的C++"></a>面向对象的C++</h2><p>这部分的C++主要是类的派生、继承、聚合</p>
<h2 id="模板元编程的C"><a href="#模板元编程的C" class="headerlink" title="模板元编程的C++"></a>模板元编程的C++</h2><p>模板元编程已经被证明是图灵完全的语言，风格特点和传统C++又有所不同</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL是官方提供的标准库，为保证标准库的高效性，库的开发者使用了部分C的特性，因此会使得STL有一点像C，也有一点像C++，需要仔细甄别</p>
<hr>
<p>点击链接查看更多C++ 技巧 ：<a href="https://blog.yu-xiaoxian.me/2019/05/03/wiki/EffectivCpp/">Effective C++</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.yu-xiaoxian.me/2020/05/09/wiki/C-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于小咸的日志">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/wiki/C-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/" itemprop="url">C++学习路线：快速入门到进阶</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-09T15:36:09+00:00">
                2020-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C/C++ 是一门底层、细粒度、功能强大、学习曲线陡峭的语言，虽然在Python等新语言的冲击下略显龙钟老态，但随着AIoT设备的兴起，以及C++社区不断推出新的版本，这门语言又重新焕发了生机。</p>
<p>本文把C++学习划分为入门、进阶、深入三个阶段，每步提供相应的学习方法和资源，并归纳了每部分需要掌握的知识点供大家复习自检，希望能够帮助大家更好地掌握这门语言。也欢迎大家告诉我更好的学习资源，本文会不断更新来帮助更多的人。</p>
<hr>
<h1 id="入门（塑料→青铜→白银）"><a href="#入门（塑料→青铜→白银）" class="headerlink" title="入门（塑料→青铜→白银）"></a>入门（塑料→青铜→白银）</h1><p>学习新知识有两个关键：快速上手、完整的知识体系，两者缺一不可：上手慢就会打击初学者的积极性，产生劝退效应；而没有完整的知识体系，初学者就是盲人摸象，想要进阶深入就变得困难重重，只会长期停留在入门阶段。我在对比多种学习方法后，认为网课是能够兼容这两点的好方法，所以这部分主要推荐网课，通过高频且较简单的练习巩固知识，符合人的认知曲线，提高学习效率。</p>
<h2 id="1-语言本身（入门）"><a href="#1-语言本身（入门）" class="headerlink" title="1. 语言本身（入门）"></a>1. 语言本身（入门）</h2><p>C++ 和 C 是不同的语言，但两者通常放在一起学习，C++完全兼容C的特性，并在C基础上加入了面向对象的特性，可以视为 C 语言的升级版，C能做到的事情 C++ 一样可以做到，C 做不到的事情 C++ 也可做到。</p>
<p>初学C++我推荐<a href="https://www.xuetangx.com/">学堂在线</a>上清华大学郑莉老师的课程：<em>C++语言程序设计基础</em>，<em>C++语言程序设计进阶</em>。在讲课过程中会有弹出的选择、填空题来巩固知识点，每一章结束一般会有三道编程题来进行练习。通过高频且难度不大的练习，将陡峭的学习曲线拉平，进度页面可以看到学习完成的进度，带给大家成就感。我把自己学这门课时的课后习题放在Github上<a href="https://github.com/Yu-Xiaoxian/c-plus-assignment">C++语言程序设计课后习题</a>，供大家参考。学完这门课程就会对C++的特性有了整体的了解，并且能够上手编写一些简单的程序，这时候可以去<a href="https://leetcode.com/">LeetCode</a> 上刷一些 Easy 题目找找存在感了。</p>
<p>这部分主要掌握的知识点是：</p>
<ul>
<li>基础语法：变量、条件、循环、字符串、数组、函数</li>
<li>指针操作、内存管理：这两项是C/C++的灵魂，是这门语言经久不衰的关键，但这也是一把双刃剑，用的好可以极大提高程序运行的速率，用不好会导致内存泄漏甚至程序崩溃</li>
<li>面向对象编程：类的定义与使用，继承与派生，这项特性保证了代码良好的复用和封装，是大型项目开发的必备因素</li>
</ul>
<p>掌握编程语言后，就要跟操作系统打交道了。</p>
<h2 id="2-应用实践（入门）"><a href="#2-应用实践（入门）" class="headerlink" title="2. 应用实践（入门）"></a>2. 应用实践（入门）</h2><p>Windows 和 Ubuntu 是操作系统的两大阵营，大家可以根据自己的需求进行选择。在Windows下编程的同学可以跳过这个部分，因为Visual Studio (Community社区版) 功能已经足够强大，不需要进行任何配置上手即用，关键还是免费的！这里说一声微软牛[哔——]。</p>
<p>如果需要在Linux 下编程的同学，我推荐<a href="https://www.xuetangx.com/">学堂在线</a>上清华大学乔林老师的课程：基于Linux的C++。学过郑莉老师的C++，乔林老师的这门课程就没有必要全部看下来了，因为前11讲内容都是在重复C++的语言特性，大家只要关注12讲的内容：Linux系统编程基础，系统性的了解 Linux 下编程的特点。后面三章感兴趣的话也可看一看：13.进程编程，14.线程编程，15.网络编程，但不学也不会有什么问题。</p>
<p>这门课程的用户体验没有郑莉老师的课程那么友好，不过用来系统性掌握Linux系统下的编程操作已经足够了。乔林老师讲解并不详细，但胜在体系完整，能够用很短的篇幅帮初学者建立对 Linux 系统完整的认知，这是我推荐这门课程的原因。因为讲解不够详细，遇到不懂问题再配合搜索引擎进行学习吧。</p>
<p>这部分主要掌握的知识点是：</p>
<ul>
<li>操作系统下软件的编译与执行：编译器、makefile</li>
<li>常用的系统调用：system, getenv</li>
</ul>
<h2 id="3-软件设计（入门）"><a href="#3-软件设计（入门）" class="headerlink" title="3. 软件设计（入门）"></a>3. 软件设计（入门）</h2><p>算法与数据结构、计算机网络、操作系统，是计算机考研必备的三门课程，也是整个计算机的基石。修炼好这三部分知识的程序员就像掌握了深厚的内功，无论是学习其他语言还是进行架构设计，都会更加得心应手，事半功倍。</p>
<h3 id="3-1-算法与数据结构"><a href="#3-1-算法与数据结构" class="headerlink" title="3.1 算法与数据结构"></a>3.1 算法与数据结构</h3><p>入门阶段不需要花费大量的精力对多种多样的算法和数据结构进行详尽的了解，但是需要掌握进本的算法分析手段，以及算法研究需要解决的问题。这里推荐<a href="https://www.xuetangx.com/">学堂在线</a>上清华大学邓俊辉老师的课程：数据结构(上)，只需要学习第一章绪论部分就可以。后续的章节可以在深入阶段再进行深挖。</p>
<p>需要掌握的知识点：</p>
<ul>
<li>使用大O记号对算法的复杂度进行分析。<h3 id="3-2-计算机网络"><a href="#3-2-计算机网络" class="headerlink" title="3.2 计算机网络"></a>3.2 计算机网络</h3>对于入门而言，这部分内容完全可以略过。只要实践中不涉及网络编程，就可以暂时不做了解。如果需要了解的话，首先应该掌握TCP/IP的五层网络结构，当遇到网络问题时，能够快速定位是哪一层出了问题，然后快速排查。</li>
</ul>
<p>知识要点：</p>
<ul>
<li>TCP/IP五层网络结构</li>
<li>常用传输层协议：TCP UDP</li>
<li>常用应用层协议：HTTP</li>
</ul>
<h3 id="3-3-操作系统"><a href="#3-3-操作系统" class="headerlink" title="3.3 操作系统"></a>3.3 操作系统</h3><p>这里并不需要对操作系统有多么深入的了解，只需要对计算机的硬件结构有初步的认识，了解程序从编译到执行的具体过程，了解堆栈的概念以及函数调用等流程。这部分内容不需要专门学习，我建议在学习C++语言的过程中，参考教材《C++程序设计》（Y.Daniel Liang），这本书中对操作系统有简单的介绍，可以在学习过程中加以了解。刚开始没看懂也没有关系，等语言学一段时间再回来看，相信会有更深的理解。</p>
<p>知识要点：</p>
<ul>
<li>计算机体系结构：CPU，内存，硬盘，I/O设备</li>
<li>内存堆栈与函数调用的关系</li>
<li>程序编译的流程：编辑→编译→链接→执行</li>
</ul>
<h1 id="进阶（黄金→钻石）"><a href="#进阶（黄金→钻石）" class="headerlink" title="进阶（黄金→钻石）"></a>进阶（黄金→钻石）</h1><p>入门的要求是了解C++这门语言的语法，能够编写一些简单的程序，进阶就要求掌握一定的工程能力，有能力管理一些大型项目。可能有读者就会有疑问，这篇文章不是讲C++学习么，为什么要掌握工程能力？这是由于C++（包括绝大多数编程语言）是为大型项目服务的，许多C++的编程习惯在语法上没有任何问题，但对大型项目很不友好。C++进阶本质上还是要提升自身的编程能力，在C++语言学习的过程中，穿插了解一些大型项目的经验，对编程能力会有很好的提升。</p>
<p>除工程能力外，C++进阶还需要了解这门语言会有哪些坑，并学会怎样避开他们。C++是一门功能强大的语言，它无比强大的能力也会带来许多问题，比如内存泄漏，这些问题一旦出现很难排查，所以需要掌握一定的经验，从程序设计开始就规避这些可能的问题。</p>
<h2 id="1-语言本身（进阶）"><a href="#1-语言本身（进阶）" class="headerlink" title="1. 语言本身（进阶）"></a>1. 语言本身（进阶）</h2><p>说起C++语言的进阶，大家第一时间想到的应该就是《C++ Primer》了，但我个人并不推荐，因为这本书实在是太厚了，可以当工具书但千万不要拿来当课本。因为这样的大部头想要读完都已经不容易了，更何况自己读完也没有办法掌握其中所有的知识点，还需要不断回炉重造。这里推荐一个系列 Scott Mayer 的《Effective C++》 《More Effective C++》 《Effective STL》，这也是《剑指Offer》的作者推荐的书，不少C++面试题目都会考察到其中的知识点。作者Scott Mayer整理了C++编程中需要注意的一些要点，每个部分对初学者来说都可能是深坑。这系列书的特点就是读起来比较轻松，条目之间都比较独立，可以随便选一条从自己感兴趣的开始，而不用像那些大部头一样慢慢地啃。每了解一个知识点都能让你对C++的理解更深一层，这里有我在读这本书过程中记录的笔记：<a href="https://blog.csdn.net/yu_xiaoxian_2018/article/details/105326205">Effective C++ 索引</a>，大家可以通过这个链接快速索引，选择自己感兴趣的条目深入了解。</p>
<p>当然如果要事无巨细地学习C++的所有语法规则，还是要去读《C++ Primer》，不过请事先留好充足的时间，以及反复回炉的心理准备。<a href="https://zhuanlan.zhihu.com/p/45024301">如何阅读《C++Primer》那么厚的书</a></p>
<p>怎样检查自己是否掌握C++的高级用法呢？这里建议找一本书的目录，比如<a href="https://blog.csdn.net/yu_xiaoxian_2018/article/details/105326205">Effective C++ 索引</a>，按照目录一条一条去看，能否通过标题想起对应的要点，如果完全理解并且没有任何疑惑，那恭喜你，已经神功初成啦。</p>
<h2 id="2-应用实践（进阶）"><a href="#2-应用实践（进阶）" class="headerlink" title="2. 应用实践（进阶）"></a>2. 应用实践（进阶）</h2><p>应用实践主要关注两个方面：程序编译和程序开发。</p>
<h3 id="2-1-程序编译"><a href="#2-1-程序编译" class="headerlink" title="2.1 程序编译"></a>2.1 程序编译</h3><p>程序编译需要掌握编译工具，如make、CMake、ninja、Bazel，make命令比较底层，大部分C++项目使用CMake和ninja，也有Google系的项目采用Bazel进行管理。这部分内容暂时没有找到很好的学习资源，建议结合官方文档使用搜索引擎进行学习掌握。</p>
<p>除了编译工具本身以外，还要掌握怎样在项目中使用第三方库。例如makefile中需要徒手链接库文件，CMakeLists中使用FIND_PACKAGE()命令。毕竟善用第三方库，不反复造轮子，才能提高效率。</p>
<p>这部分内容也没必要掌握得多么精通，只要给出CMakeLists.txt能够看懂，会使用第三方库，能够照猫画虎给自己的工程写出编译文件就可以了。</p>
<h3 id="2-2-程序开发"><a href="#2-2-程序开发" class="headerlink" title="2.2 程序开发"></a>2.2 程序开发</h3><p>程序开发就主要根据工作的不同进行专项学习了，这里也不做过多展开，主要介绍几个常用的领域：</p>
<ul>
<li>图形界面：目前使用最广的C++图形界面框架应该是Qt，提供跨平台的支持，对跨平台开发比较友好</li>
<li>游戏开发：这里游戏开发单指使用物理引擎进行的开发，如Unity3D</li>
<li>后端开发：包括Web后端和游戏后端，需要与数据库以及前端交互，需要掌握的技能有网络编程（socket通信，epoll异步通信，asio异步通信库），以及数据库编程（MySQL C++ connector）</li>
<li>嵌入式开发：嵌入式开发又是一个大的话题了，开发逻辑与Linux操作系统有很大的不同，就不做过多展开，目前比较常用的有开源嵌入式操作系统RTOS，以及自动驾驶领域使用较多的实时操作系统QNX</li>
</ul>
<p><strong>注！</strong>：游戏开发和后端开发并不是笔者的领域，认识可能比较片面，欢迎大家补充。</p>
<h2 id="3-程序设计（进阶）"><a href="#3-程序设计（进阶）" class="headerlink" title="3. 程序设计（进阶）"></a>3. 程序设计（进阶）</h2><h3 id="3-1-数据结构与算法"><a href="#3-1-数据结构与算法" class="headerlink" title="3.1 数据结构与算法"></a>3.1 数据结构与算法</h3><p>不知道大家是否还记得之前推荐的《C++数据结构与算法》（学堂在线），入门阶段我们只了解了复杂度计算的方法，那么进阶就需要把这部分内容啃下来了。邓俊辉老师的课提供大量动画进行讲解，还有大量的练习，还有在线OJ系统，可以快速巩固知识，掌握常用的数据结构和算法知识。</p>
<p>学完这部分内容后，大家应该掌握以下知识点：</p>
<ul>
<li>常用数据结构：链表、图、二叉树、红黑树、散列表等</li>
<li>常用数据结构的遍历方法以及复杂度：深度优先遍历（O(nlog(n)），宽度优先遍历，等等</li>
<li>常用算法及其复杂度：排序（冒泡，归并，堆排序等），字符串匹配（KMP，BM等），最短路径（Dijkstra），等</li>
</ul>
<h3 id="3-2-计算机操作系统"><a href="#3-2-计算机操作系统" class="headerlink" title="3.2 计算机操作系统"></a>3.2 计算机操作系统</h3><p>操作系统进阶就需要了解怎样能更高效地进行计算了，这是发挥C++优势的法宝。要想完全掌握，就一定需要把《深入理解计算机系统》这本书读完。这里给一个链接帮大家啃这本书 <a href="https://www.cs.cmu.edu/~213/schedule.html">CMU：CSAPP</a>，其中有7个动手实验，能够帮大家很好地掌握操作系统的一些知识。</p>
<ul>
<li>Data Lab：bit 运算与float的相关操作</li>
<li>Bomb Lab：阅读汇编破解密码</li>
<li>Attack Lab：Buffer Overflow 攻击</li>
<li>Cache Lab：实现一个cache simulator已经一个cache efficient的矩阵转置。</li>
<li>Shell Lab：用多进程实现一个简单的linux shell。主要是熟悉进程控制与同步。</li>
<li>Malloc Lab：自己写一个C语言的malloc函数。</li>
<li>Proxy Lab：写一个支持HTML的多线程Server。熟悉Unix网络编程与多线程的控制与同步。</li>
</ul>
<p>这里推荐Cache Lab和Shell Lab，可以对计算机缓存效率和进程线程调度有直观的认知，方便深入了解C++优化方法。</p>
<p>要点：</p>
<ul>
<li>程序的存储结构是怎样的？</li>
<li>怎样设计能够提高CPU缓存的利用率？</li>
<li>怎样对齐内存更加紧凑？</li>
</ul>
<h3 id="3-3-计算机网络"><a href="#3-3-计算机网络" class="headerlink" title="3.3 计算机网络"></a>3.3 计算机网络</h3><p>计算机网络没必要深入了解过多，完成<a href="https://www.cs.cmu.edu/~213/schedule.html">CMU</a>的Proxy Lab基本就够了。因为目前网络通信协议基本成熟，已经有大量成熟稳定的网络库存在，因此我们不需要投入大量精力在协议实现上，而是需要理解协议为什么要这样设计。比如TCP的连接的三次握手和四次挥手，是面试中的经典题目，虽然在实际开发中从来不会用，但可以用来考察面试者的基本功。相比底层的TCP、UDP协议，HTTP/HTTPS协议以及最近流行的RPC，在应用中会经常遇到，大家可以了解一下这些协议的应用方法和特点。</p>
<p>但如果是运维、IT、架构师之类的岗位，仅仅满足于协议的使用是远远不够的，还需要更深入的了解DNS，防火墙等等协议，这里就不做展开了。</p>
<p>要点：</p>
<ul>
<li>TCP和UDP的区别</li>
<li>TCP连接的三次握手和四次挥手</li>
<li>HTTP和HTTPS的特点</li>
</ul>
<h3 id="3-4-设计模式与编程风格"><a href="#3-4-设计模式与编程风格" class="headerlink" title="3.4 设计模式与编程风格"></a>3.4 设计模式与编程风格</h3><p>设计模式没有很好的中文版书籍，大家常提的《大话设计模式》和《设计模式之禅》我并不推荐，这两本书本意是想要通俗地解释设计模式，但只是蜻蜓点水地总结了一下《Design Pattern》这本神作，如果想要深入理解设计模式，还是需要啃《Design Pattern》。这里我推荐一本书《C++编程风格》，这本书分了六个问题，分别从最直接的代码开始，一步一步优化代码，优化过程中解释了为什么要这样做的原因。这本书结合《Design Pattern》中的六大原则，可以帮助我们形成良好的设计思维，当有了设计思维再去理解设计模式会简单很多。</p>
<p>掌握要点：程序设计六大原则</p>
<ul>
<li>单一职责原则</li>
<li>里氏代换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>迪米特法则</li>
<li>开闭原则</li>
</ul>
<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>目前文章只完成了入门和进阶的学习路线，深入的学习路线会在整理后更新出来。然而在完成进阶部分的时候，笔者就感觉到自己视野有限，较难从更深更广的维度来指出一条学习路线，也希望大家能够多提供一些自己的学习资源和建议，能够使这个学习路线更加丰满。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.yu-xiaoxian.me/2019/11/22/Mannual/install-gost-as-system-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于小咸的日志">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/22/Mannual/install-gost-as-system-service/" itemprop="url">配置gost开机自启</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-22T13:03:46+00:00">
                2019-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="配置-gost-开机自启"><a href="#配置-gost-开机自启" class="headerlink" title="配置 gost 开机自启"></a>配置 gost 开机自启</h1><p><a href="https://github.com/ginuerzh/gost">gost</a>是GO语言实现的安全隧道，支持多种网络协议，对多平台有着很好的支持。本文将gost配置为系统服务，从而实现开机自启。</p>
<p>ubuntu系统中，开机自启有很多种实现方案，比如Startup Application, 或者init.d中配置开机脚本，不过ubuntu 16.04之后的版本，比较推荐使用systemd进行管理。systemd 在<a href="## 参考链接">阮一峰的文章</a>中已经有详细的介绍，此处不做赘述，直接介绍配置的具体细节。</p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>第一步，首先下载最新的 gost，并拷贝到/usr/bin/目录下</p>
<p>第二步，在/etc/systemd/system/目录下新建名为gost.service的文件，文件具体内容如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=GOST SERVER</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">EnvironmentFile=/path/to/enviroment/file</span><br><span class="line">ExecStart=/usr/bin/gost -L &quot;http2://$&#123;USER&#125;:$&#123;PASS&#125;@$&#123;DOMAIN&#125;:$&#123;PORT&#125;?cert=$&#123;CERT&#125;&amp;key=$&#123;KEY&#125;&amp;probe_resist=code:404&quot;</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=42s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>其中USER PASS等变量定义在 EnvironmentFile 中，EnvironmentFile 的格式与shell 脚本类似</p>
<p>最后，依次运行以下命令启动服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务</span></span><br><span class="line">systemctl start gost</span><br></pre></td></tr></table></figure>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">阮一峰：Systemd 入门教程：实战篇</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">阮一峰：Systemd 入门教程：命令篇</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.yu-xiaoxian.me/2019/08/15/speedup-cpp-iostream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于小咸的日志">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/speedup-cpp-iostream/" itemprop="url">加速C++的读写</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T16:35:36+00:00">
                2019-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>今天在<a href="www.leetcode.com">LeetCode</a>刷题，看到高手的答案中有下面这行代码，了解了一下这些代码的含义，发现了提高C++读写速度的方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">auto</span> speedup = []()&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;&#125;();</span><br></pre></td></tr></table></figure>
<p>C++中的输入输出流为std::cin和std::cout，与之对应的C中的输入输出分别为scanf()和printf()。不少人有误解说C++的输入输出比C的慢，然而这时错误的认知，玄机就体现在以上代码中。C++为兼容C，并保证输入输出的线程安全，将C++的输入输出流与C的绑定在了一起，也就是说C++并不维护缓存区，而是将保存在C的缓存区中，这样每次IO都会调用一次flush()，因此导致开销较大。</p>
<p>而cin.tie()默认将输入绑定到cout，这样每一行输入都能够被打印出来。而将cin绑定到空指针，能够进一步提高输入的速度。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio">cpp-reference: sync_with_stdio</a></li>
<li><a href="https://blog.csdn.net/jrrrj/article/details/81319369">cin.tie与sync_with_stdio加速时输入输出</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.yu-xiaoxian.me/2019/05/15/theory/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于小咸的日志">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/theory/%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/" itemprop="url">绕固定坐标轴旋转与绕自身坐标轴旋转的一致性证明</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T15:03:16+00:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>作者：Tai Fook<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/jiongjiongxia123/article/details/90236737">https://blog.csdn.net/jiongjiongxia123/article/details/90236737</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
<font size=2 color=gray>最近强子在学习坐标变换的内容，对于欧拉角变换矩阵很是好奇，怎么理解“绕固定坐标轴旋转与绕自身坐标轴旋转的一致性”呢，跟他讨论了许久，找到了一种比较清晰明了的证明方法，便于直观理解，原文发表在了强子的CSDN上，这里贴出来分享给大家。</font>

<hr>
<p>最近在看人头姿态和视线方向检测的东西,需要考虑坐标系与坐标系之间的旋转.用欧拉角表示坐标系的旋转时存在两种旋转方法,另外旋转的顺序也会对旋转结果有影响,查了一些资料总结一下结果.</p>
<p>描述坐标系<strong>B</strong>相对于坐标系<strong>A</strong>的姿态有两种方式:第一种是绕固定坐标轴旋转,第二种是绕自身坐标轴旋转.假设坐标系<strong>A</strong>为世界坐标系(不动),坐标系<strong>B</strong>为旋转坐标系,两个坐标系在开始时重合,则:</p>
<ul>
<li><p>绕固定坐标轴旋转:</p>
<p>先将<strong>B</strong>绕<strong>A</strong>的<strong>X</strong>轴旋转α,再将<strong>B</strong>绕<strong>A</strong>的<strong>Y</strong>轴旋转β,最后将<strong>B</strong>绕<strong>A</strong>的<strong>Z</strong>轴旋转γ.旋转过程中坐标系<strong>A</strong>是不动的,其三个坐标轴也是固定的,因此称这种旋转方法为绕固定轴旋转.注意这里的旋转方向为先<strong>X</strong>轴,再<strong>Y</strong>轴,最后<strong>Z</strong>轴.</p>
</li>
<li><p>绕自身坐标轴旋转:</p>
<p>先将<strong>B</strong>绕<strong>B</strong>的<strong>Z</strong>轴旋转γ,再将<strong>B</strong>绕<strong>B</strong>的<strong>Y</strong>轴旋转β,最后将<strong>B</strong>绕<strong>B</strong>的<strong>X</strong>轴旋转α.旋转过程中坐标系<strong>B</strong>是变化的,其三个坐标轴也是变化的,称这种旋转方法为绕固自身旋转.注意这里的旋转方向为先<strong>Z</strong>轴,再<strong>Y</strong>轴,最后<strong>X</strong>轴.和第一种旋转方式的旋转顺序不同,原因是后面要给出的结论.</p>
</li>
</ul>
<p>结论:</p>
<p>以绕固定轴方式,先<strong>X</strong>轴转α,再<strong>Y</strong>轴转β,最后<strong>Z</strong>轴转γ的旋转和以绕自身轴方式,先<strong>Z</strong>轴转γ,再<strong>Y</strong>轴转β,最后<strong>X</strong>轴转α的旋转是等效的,下面给出”僵硬”的数学证明.</p>
<h2 id="证明-僵硬的"><a href="#证明-僵硬的" class="headerlink" title="证明(僵硬的):"></a>证明(僵硬的):</h2><p>我们知道,坐标轴的旋转可以用旋转矩阵来表示,为了证明上述两种旋转方法是等效的,只需要证明两种旋转方法对应的旋转矩阵是相同的.</p>
<p>对于绕固定轴方式,先<strong>X</strong>轴转α,再<strong>Y</strong>轴转β,最后<strong>Z</strong>轴转γ的旋转,其旋转矩阵<strong>R</strong>容易得到:</p>
<script type="math/tex; mode=display">
R_x(α)=\left [\begin{matrix} 1&0&0 \\ 0&cos(\alpha)&-sin(\alpha) \\0&sin(\alpha)&cos(\alpha)\end{matrix}\right ]</script><script type="math/tex; mode=display">
R_Y(β)=\left [\begin{matrix} cos(\beta)& 0&sin(\beta) \\ 0&1&0 \\-sin(\beta)&0&cos(\beta)\end{matrix}\right ]</script><script type="math/tex; mode=display">
R_Z(γ)=\left [\begin{matrix} cos(\gamma)&-sin(\gamma)&0 \\ sin(\gamma)&cos(\gamma)&0 \\0&0&1\end{matrix}\right ]</script><p>对于绕自身轴方式,先<strong>Z</strong>轴转γ,再<strong>Y</strong>轴转β,最后<strong>X</strong>轴转α的旋转,其旋转矩阵<strong>R</strong>.首先给出坐标系绕任意以单位向量表示方向的定轴(x,y,z)旋转θ 的旋转矩阵为:</p>
<script type="math/tex; mode=display">
r=\left [\begin{matrix} 
cos(\theta)+(1-cos(\theta))x^2
& (1-cos(\theta))xy-sin(\theta)z
& (1-cos(\theta))xz+sin(\theta)y

\\(1-cos(\theta))xy+sin(\theta)z
& cos(\theta)+(1-cos(\theta))y^2
& (1-cos(\theta))yz-sin(\theta)x

\\(1-cos(\theta))xz-sin(\theta)y
& (1-cos(\theta))yz+sin(\theta)x
& cos(\theta)+(1-cos(\theta))z^2\end{matrix}\right ]</script><p>则先<strong>Z</strong>轴转γ对应的旋转矩阵</p>
<script type="math/tex; mode=display">
R_Z(γ)=\left [\begin{matrix} 
cos(\gamma)&-sin(\gamma)&0 
\\ sin(\gamma)&cos(\gamma)&0 
\\0&0&1\end{matrix}\right ]</script><p>旋转后的<strong>Y</strong>轴由(0,1,0) 变成了(−sin(γ),cos(γ),0) 再按照绕任意轴的公式计算得到绕此时的<strong>Y</strong>轴旋转β对应的旋转矩阵为:</p>
<script type="math/tex; mode=display">
R_Y(β)=\left [\begin{matrix} 
cos(\beta)-sin^2(\gamma)(cos(\beta)-1)
& cos(\gamma)sin(\gamma)(cos(\beta)-1)
& sin(\beta)cos(\gamma)

\\ cos(\gamma)sin(\gamma)(cos(\beta)-1)
& cos(\beta)-cos^2(\gamma)(cos(\beta)-1)
& sin(\beta)sin(\gamma)

\\-sin(\beta)cos(\gamma)
& -sin(\beta)sin(\gamma)
& cos(\beta)\end{matrix}\right ]</script><p>则两步旋转后的旋转矩阵为</p>
<script type="math/tex; mode=display">
R_Y(β)×R_Z(γ)=\left[\begin{matrix}
cos(\beta)cos(\gamma)& -sin(\gamma)& sin(\beta)cos(\gamma)
\\cos(\beta)sin(\gamma)& cos(\gamma)& sin(\beta)sin(\gamma)
\\-sin(\beta)& 0& cos(\beta)\end{matrix}\right]</script><p>旋转后的<strong>X</strong>轴由(1.0,0) 变成了(cos(β)cos(γ),−sin(γ),sin(β)cos(γ)) 再按照绕任意轴的公式计算得到绕此时的<strong>X</strong>轴旋转α对应的旋转矩阵为</p>
<script type="math/tex; mode=display">
RX(α) R_X(\alpha)RX(α):</script><p>这个矩阵实在太长了我不想写了,反正就是按照上面的任意轴公式,把x=cos(β)cos(γ),y=−sin(γ),z=sin(β)cos(γ) 往里一代就行了.</p>
<p>最后总的旋转矩阵</p>
<script type="math/tex; mode=display">
\textbf{R} = R_X(\alpha)\times R_Y(\beta)\times R_Z(\gamma)</script><p> 把各部的结果代进去一算,就得到了最终结果:</p>
<script type="math/tex; mode=display">
\textbf{R} = \left [\begin{matrix} 
cos(\beta)cos(\gamma)& sin(\alpha)sin(\beta)cos(\gamma)-cos(\alpha)sin(\gamma)& cos(\alpha)sin(\beta)cos(\gamma)+sin(\alpha)sin(\gamma)
\\cos(\beta)sin(\gamma)& sin(\alpha)sin(\beta)sin(\gamma)+cos(\alpha)cos(\gamma)& cos(\alpha)sin(\beta)sin(\gamma)-sin(\alpha)cos(\gamma)
\\-sin(\beta)& sin(\alpha)cos(\gamma)&cos(\alpha)cos(\gamma)\end{matrix}\right ]</script><p>和第一种旋转方法得到的结果相同.于是证明了前面给出的结论.之所以说这是一种很”僵硬”的证明办法,是因为整个过程是用 Matlab 强行代公式计算出来的,中间结果可能看起来很啰嗦式子很长,但是你把他们都乘起来,就能化简出相同的结果.实际上应该有更优雅的立体几何投影证明方法,但是空间想象能力实在太差,想不出来.如果有清楚的朋友请指点一下.</p>
<p>经过和泡儿鱼的讨论,想出了比较简洁的证明方法,写在下面:</p>
<h2 id="证明-优雅的"><a href="#证明-优雅的" class="headerlink" title="证明(优雅的):"></a>证明(优雅的):</h2><p>旋转矩阵可以用来表示坐标系和坐标系之间旋转的变换关系,也可以用来表示同一个坐标系下坐标旋转前后的变换关系,从后者的角度出发可以得到一个比较简洁又清晰的证明方法.</p>
<p>我们的任务是证明:以绕固定轴方式,先绕<strong>X</strong>轴转α,再绕<strong>Y</strong>轴转β,最后绕<strong>Z</strong>轴转γ的旋转和以绕自身轴方式,先绕<strong>Z</strong>轴转γ,再绕<strong>Y</strong>轴转β,最后绕<strong>X</strong>轴转α的旋转是等效的.在上述僵硬的证明方法中,我们通过计算证明了两种方式下坐标系前后的变换矩阵是相同的.下面的方法中,我们证明A坐标系中有一个向量,按照这两种方式去旋转,旋转后它们在原A坐标系下转到了同一个位置,即证明了上述结论.</p>
<p>假设有一个固定的世界坐标系<strong>A</strong>,其中有一个向量<strong>a</strong>,它在<strong>A</strong>中的坐标为<strong>Ra</strong> .</p>
<p>对于第一种方式的变换:</p>
<p>向量<strong>a</strong>先绕<strong>A</strong>的<strong>X</strong>轴转α,再绕<strong>A</strong>的<strong>Y</strong>轴转β,最后绕<strong>A</strong>的<strong>Z</strong>轴转γ,则三步旋转过后它在坐标系<strong>A</strong>中的坐标:</p>
<script type="math/tex; mode=display">
\textbf{Ra}'=R_Z(\gamma) \times R_Y(\alpha) \times R_X(\alpha) \times\textbf{Ra}</script><p>其中:</p>
<script type="math/tex; mode=display">
R_x(α)=\left [\begin{matrix} 1&0&0 \\ 0&cos(\alpha)&-sin(\alpha) \\0&sin(\alpha)&cos(\alpha)\end{matrix}\right ]</script><script type="math/tex; mode=display">
R_Y(β)=\left [\begin{matrix} cos(\beta)& 0&sin(\beta) \\ 0&1&0 \\-sin(\beta)&0&cos(\beta)\end{matrix}\right ]</script><script type="math/tex; mode=display">
R_Z(γ)=\left [\begin{matrix} cos(\gamma)&-sin(\gamma)&0 \\ sin(\gamma)&cos(\gamma)&0 \\0&0&1\end{matrix}\right ]</script><p>对于第二种方式的变换:</p>
<p>假设除了不动的世界坐标系<strong>A</strong>以外,还有一个和向量<strong>a</strong>固连在一起的向量坐标系<strong>B</strong>.固连的向量坐标系和向量<strong>a</strong>是固连的不会产生相对运动,即向量<strong>a</strong>怎么转固连坐标系<strong>B</strong>就怎么转.那么显然,任何转动后,向量<strong>a</strong>在固连坐标系<strong>B</strong>下的坐标都是不变的,且始终等于未发生任何转动时向量<strong>a</strong>在世界坐标系<strong>A</strong>下的坐标<strong>Ra</strong> .因为向量<strong>a</strong>在固连坐标系<strong>B</strong>中的位置不变.</p>
<p>第二种方式的变换为:向量<strong>a</strong>先绕<strong>B</strong>的<strong>Z</strong>轴转γ,再绕<strong>B</strong>的<strong>Y</strong>轴转β,最后绕<strong>B</strong>的<strong>X</strong>轴转α,将转动步骤倒过来叙述更方便</p>
<p>对于第三步转动,即向量<strong>a</strong>绕第二次转动后的固连坐标系<strong>B”</strong>的<strong>X</strong>轴转α,有:</p>
<script type="math/tex; mode=display">
\textbf{Ra2} = R_X(\alpha) \times \textbf{Ra3}</script><p>其中<strong>Ra2</strong>为三次转动后向量<strong>a</strong>在第二次转动后的固连坐标系<strong>B”</strong>中的坐标,R<strong>a3</strong> 为三次转动后向量<strong>a</strong>在第三次转动后的固连坐标系<strong>B”’</strong> 中的坐标.<strong>RX</strong>(α) 为第二次转动后的固连坐标系<strong>B”</strong> 和第三次转动后的固连坐标系<strong>B”’</strong> 之间的旋转矩阵.由于第三次旋转就是绕着<strong>B”</strong>的<strong>X</strong>轴转了α,因此RX(α) ,或者说<strong>B”</strong> 和<strong>B”’</strong> 之间的变换矩阵就是:</p>
<script type="math/tex; mode=display">
R_X(\alpha) = \left [\begin{matrix} 1& 0& 0 
\\ 0& cos(\alpha)& -sin(\alpha) 
\\0& sin(\alpha)& cos(\alpha)\end{matrix}\right ]</script><p>同理对于第二步转动,有:</p>
<script type="math/tex; mode=display">
\textbf{Ra1} = R_Y(\beta) \times \textbf{Ra2}</script><p>各变量的意义类似第三步不再赘述.</p>
<script type="math/tex; mode=display">
R_Y(\beta) = \left [\begin{matrix} 
cos(\beta)& 0& sin(\beta) 
\\ 0& 1& 0 
\\-sin(\beta)& 0& cos(\beta)\end{matrix}\right ]</script><p>同理对于第一步转动有:</p>
<script type="math/tex; mode=display">
\textbf{Ra0} = R_Z(\gamma) \times \textbf{Ra1}</script><p>其中<strong>Ra0</strong> 为三次转动后向量<strong>a</strong>在第0次转动后的固连坐标系<strong>B”</strong> 中的坐标,也就是在世界坐标系中的坐标<strong>Ra’</strong>,即:</p>
<script type="math/tex; mode=display">
\textbf{Ra}' = R_Z(\gamma) \times \textbf{Ra1}</script><p>其中:</p>
<script type="math/tex; mode=display">
R_Z(\gamma) = \left [\begin{matrix} 
cos(\gamma)& -sin(\gamma)& 0 
\\ sin(\gamma)& cos(\gamma)& 0 
\\0& 0& 1\end{matrix}\right ]</script><p>把三步转动串起来看,有:</p>
<script type="math/tex; mode=display">
\begin{align}
\textbf{Ra}' &= R_Z(\gamma) \times \textbf{Ra1} \\
&= R_Z(\gamma) \times(R_Y(\beta) \times \textbf{Ra2})\\
&= R_Z(\gamma) \times(R_Y(\beta) \times (R_X(\alpha) \times \textbf{Ra3}))\\
&=R_Z(\gamma) \times R_Y(\beta) \times R_X(\alpha) \times \textbf{Ra3}
\end{align}</script><p>又因为<strong>Ra3</strong>是第三次转动后向量<strong>a</strong>在第三次转动后的固连坐标系<strong>B’’</strong>的坐标,由于相对位置不变,这个值就等于未发生转动时向量<strong>a</strong>在世界坐标系<strong>A</strong>中的坐标,即:</p>
<script type="math/tex; mode=display">
\textbf{Ra3} = \textbf{Ra}</script><p>则有:</p>
<script type="math/tex; mode=display">
\textbf{Ra}'=R_Z(\gamma) \times R_Y(\alpha) \times R_X(\alpha) \times\textbf{Ra3} = R_Z(\gamma) \times R_Y(\alpha) \times R_X(\alpha) \times\textbf{Ra}</script><p>与第一种方式的变换结果相同.即同一个向量经过两种方式的变换后在世界坐标系中的坐标相同,也证明了这两种变换是等效的.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下就是,如果是坐标系或者向量绕着固定的坐标轴旋转,相当于每转一次产生一个旋转矩阵,然后按旋转顺序将这些旋转矩阵左乘起来.如果是坐标系或者向量绕着自身的坐标轴旋转,相当于每转一次产生一个旋转矩阵,然后按旋转顺序将这些矩阵右乘起来.要注意后者的每一步旋转产生的旋转矩阵,不要以世界坐标系为基准去算,而是以每次旋转前的坐标系去算,也就是每次旋转矩阵只描述当前这次旋转前后的坐标系之间的转换矩阵!!!</p>
<p>费了半天劲希望把事情说明白了,我其实很担心哪个地方有笔误没写清楚,如果有的话请帮忙指出来.谢谢!</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>网上也找到了其他类似的证明方法,看起来似乎更简洁也更容易理解,贴出来供参考:</p>
<p><a href="http://blog.miskcoo.com/2016/12/rotation-in-3d-space">Rotation in 3d Space</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.yu-xiaoxian.me/2019/05/03/Mannual/MermaidDiagram/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于小咸的日志">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Mannual/MermaidDiagram/" itemprop="url">配置 Hexo 支持 Mermaid（流程图、甘特图）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T23:43:16+00:00">
                2019-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mannual/" itemprop="url" rel="index">
                    <span itemprop="name">Mannual</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Mermaid-示例"><a href="#Mermaid-示例" class="headerlink" title="Mermaid 示例"></a>Mermaid 示例</h1><p>Merimaid 是一个简单的流程图生成工具，它语法简单，内嵌于markdown编辑器 Typora 中，下面是Mermaid 绘图的几个示例：流程图、甘特图和序列图。 </p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><pre class="mermaid">graph LR;
A[Talker] --Hello World!--> B[Listener]</pre>

<h2 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h2><pre class="mermaid">gantt
dateFormat  YYYY-MM-DD
title Test GANTT diagram

section A section
Completed work  :done,    des1, 2014-01-06,2014-01-08
Active work     :active,  des2, 2014-01-09, 3d
Future work     :         des3, after des2, 5d</pre>

<h2 id="序列图"><a href="#序列图" class="headerlink" title="序列图"></a>序列图</h2><pre class="mermaid">sequenceDiagram
    participant Alice
    participant John
    Alice->>John: Hello John, how are you?
    John->>Alice: Fine, thanks, and you?
    Alice->>John: I'm fine, too.</pre>

<h1 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h1><p>相信大家都很熟悉 Hexo 这款静态博客生成工具，目前 Hexo官方也提供了 Mermaid 的支持，只不过还没有写入默认配置，需要手动对配置文档进行修改，主要修改以下两处地方。</p>
<ol>
<li><p>在根目录下的 _config.ymal文件中添加</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">&quot;7.1.2&quot;</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>修改对应主题的配置文件，从而激活js模块，以next为例，在themes/next/layout/_partials/footer.swig 中添加</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">%</span> <span class="string">if</span> <span class="string">(theme.mermaid.enable)</span>  <span class="string">%</span>&#125;</span><br><span class="line">  <span class="string">&lt;script</span> <span class="string">src=&#x27;https://unpkg.com/mermaid@&#123;&#123;</span> <span class="string">theme.mermaid.version</span> <span class="string">&#125;&#125;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt;</span></span><br><span class="line">  <span class="string">&lt;script&gt;</span></span><br><span class="line">    <span class="string">if</span> <span class="string">(window.mermaid)</span> &#123;</span><br><span class="line">      <span class="string">mermaid.initialize(</span>&#123;<span class="attr">theme:</span> <span class="string">&#x27;forest&#x27;</span>&#125;<span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="string">&lt;/script&gt;</span></span><br><span class="line">&#123;<span class="string">%</span> <span class="string">endif</span> <span class="string">%</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以将Typora中画好的图直接传到博客上进行解析</p>
</li>
</ol>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://tyloafer.github.io/posts/7790/">Hexo中引入Mermaid流程图</a></li>
<li><a href="https://github.com/webappdevelp/hexo-filter-mermaid-diagrams">GitHub:hexo-filter-mermaid-diagrams</a></li>
<li><a href="https://mermaidjs.github.io/">mermaid GitBook</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.yu-xiaoxian.me/2019/05/03/wiki/EffectivCpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于小咸的日志">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/wiki/EffectivCpp/" itemprop="url">Effective C++ 目录</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T21:43:16+00:00">
                2019-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wiki/" itemprop="url" rel="index">
                    <span itemprop="name">Wiki</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Effective-C-目录"><a href="#Effective-C-目录" class="headerlink" title="Effective C++ 目录"></a>Effective C++ 目录</h1><p>《Effective C++》 由Scott Meyers 编写，是从初级C++程序员向高级进阶的桥梁，特别适合C++的初学者，或者准备面试的程序员，这本书中讲的全部是资深程序员的经验和技巧，对C++的工程应用有着很大的帮助。读了这本书，你将会理解工程源码中一些奇怪的处理。费时一个多月读完了这本书，下面是汇总的目录。</p>
<p>注：其中第25条讲了模板和派生类中对函数名的遮掩，第35条提到了Strategy模式，第45条讲了成员函数模板的注意事项，第49条讲了new_handler的使用技巧，这几条涉及概念比较多，需要仔细梳理。搞明白以后对C++的使用会有更加深刻地认识。</p>
<h2 id="习惯C"><a href="#习惯C" class="headerlink" title="习惯C++"></a>习惯C++</h2><ol>
<li><a href="https://blog.yu-xiaoxian.me/2020/05/26/wiki/EffectivCpp-tip01/">C++ 是一个语言联邦</a></li>
<li>尽量使用 inline enum const 代替#define</li>
<li><a href="https://blog.yu-xiaoxian.me/2020/05/26/wiki/EffectivCpp-tip03/">尽可能使用 const</a></li>
<li>确定对象使用前已经被初始化</li>
</ol>
<h2 id="构造，析构，赋值"><a href="#构造，析构，赋值" class="headerlink" title="构造，析构，赋值"></a>构造，析构，赋值</h2><ol>
<li>了解C++默默编写了哪些函数</li>
<li>如果不想用编译器自动生成的函数，就明确拒绝</li>
<li>为带多态性质的基类设计 virtual 析构函数</li>
<li>析构函数绝对不要吐出异常，要么在析构函数中处理，要么在类的普通函数中丢给用户</li>
<li>不要在构造和析构函数中调用虚函数</li>
<li>令赋值操作符返回一个*this指针，使其实现连锁形式</li>
<li>在赋值操作符中考虑自我赋值以及异常安全，可以使用copy and swap 技术</li>
<li>复制对象时需要复制每一个成分，并且复制构造函数和赋值操作符不能相互调用</li>
</ol>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><ol>
<li>使用对象管理资源，使用auto_ptr, tr1:shared_prt 等类指针对象</li>
<li>注意资源管理对象的copy行为，根据所管理的对象特点选择不同的方案：禁止复制或者计数复制</li>
<li>在资源管理对象中保留对原始对象的访问，可以使用显式转换或者隐式转换</li>
<li>成对使用new 和 delete 时使用相同的形式：数组形式的 new 需要调用 delete[]</li>
<li>以独立语句将 newed 指针置入智能指针，由于编译器会对同一语句中的操作进行重新排序</li>
</ol>
<h2 id="接口编写"><a href="#接口编写" class="headerlink" title="接口编写"></a>接口编写</h2><ol>
<li>使你的接口不容易被误用，传递指针时多使用类指针对象，传入多个形参时使用类</li>
<li>设计class就像设计type，这是类设计过程中需要注意的一系列要点</li>
<li>传递形参时多使用引用而非值，传递引用可防止对象被切割</li>
<li>函数的返回值，不能是对象的引用</li>
<li>成员变量设置为private，可以保证数据访问一致性，细微划分访问控制，允诺约束条件得以保证</li>
<li>尽可能使用non-member和non-member函数替代member函数，以此保证最好的封装性</li>
<li>所有参数均需要类型转换，采用non-member函数</li>
<li>写没有异常抛出的swap函数，要替代系统自带的swap函数时，需要写多个 member，non-member，特化swap</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol>
<li>尽可能延后变量定义式的出现，直到他可以被初始化，循环中为了提高封装性，应该把变量赋值放在循环体内</li>
<li>尽量少做转型，特别是开销巨大的dynamic_cast，多使用C++的转型而非C的旧转型</li>
<li>避免返回handle指向对象内部，避免指针指向空的地址，典型例子就是vector返回对象的引用</li>
<li>异常安全函数提三种保证之一：基本保证，强烈保证，不抛出异常</li>
<li>谨慎使用inline，他会导致代码膨胀，会给程序升级带来难度，指针调用的函数不会被inline</li>
<li>将文件编译依存度降低，通过分离声明和定义，有handle class和interface class两种方式</li>
</ol>
<h2 id="继承与面向对象设计"><a href="#继承与面向对象设计" class="headerlink" title="继承与面向对象设计"></a>继承与面向对象设计</h2><ol>
<li>使用public继承描述is-a关系：但是“鸟-企鹅”、“长方形-正方形”等常识关系并不满足继承关系，因为派生类不一定适用基类的方法</li>
<li>不要隐藏继承而来的名称</li>
<li>区分接口继承与实现继承：使用protect函数来实现默认功能</li>
<li>虚函数以外的方法：NVI和Strategy模式(使用另外一个继承体系的虚函数)</li>
<li>绝对不要重新定义继承来的非虚函数</li>
<li>绝不重新定义继承而来的缺省参数，非虚函数一定不要改变，虚函数的缺省参数也不要改变，会导致调用中调用基类的缺省参数</li>
<li>通过复用表示has-a关系和根据某物实现</li>
<li>明智而审慎的使用private继承，可以产生空基类空间最优</li>
<li>明智而审慎的使用多重继承，多重继承比较复杂，并且会带来额外的开销</li>
</ol>
<h2 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h2><ol>
<li>了解隐式接口和编译期多态，模板对数据类型的要求也是一种接口</li>
<li>typename的双重含义：一种在模板声明语句中跟class等价，一种用来声明内嵌从属类型</li>
<li>学习处理模板化内基类内的名称：使用this指针指出，或在函数内声明，否则编译器不会进入模板化内基类进行查找</li>
<li>将与参数无关的代码抽离templates</li>
<li>运用成员函数模板兼容所有可接受类型</li>
<li>需要类型转换时提供非成员模板函数，但是需要声明为友元</li>
<li>使用trait class表现类型信息</li>
<li>认识TMP模板元编程，可以在编译期查出程序错误</li>
</ol>
<h2 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h2><ol>
<li>了解new_handler的行为，new失败时会不断调用new_handler函数，可以为自己的类定义独自的new_handler函数，也可以使用模板类来实现</li>
<li>了解new和delete合理的替换时机</li>
<li>编写new和delete时需要固守常规，new需要循环调用new_handler，new需要处理0byte请求，delete需要处理空指针，此外还需要应对继承带来的尺寸问题</li>
<li>写了placement new也需要写placement delete，类中但凡定义一种new，就会掩盖所有的global new</li>
</ol>
<h2 id="杂项讨论"><a href="#杂项讨论" class="headerlink" title="杂项讨论"></a>杂项讨论</h2><ol>
<li>不要轻易忽视编译器的警告,不可过分依赖警告，因为不同编译器的警告标准不同</li>
<li>熟悉tr1在内的标准程序库</li>
<li>熟悉boost</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.yu-xiaoxian.me/2018/04/16/SelfDriving/%E7%82%B9%E4%BA%91%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于小咸的日志">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/SelfDriving/%E7%82%B9%E4%BA%91%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/" itemprop="url">点云匹配算法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T19:20:16+00:00">
                2018-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithms</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="NDT"><a href="#NDT" class="headerlink" title="NDT"></a>NDT</h1><p>Normalized Distribution Transform: 正态分布转换匹配</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>NDT算法可以概括为以下三步，其中迭代优化是核心。</p>
<ul>
<li><strong>预处理</strong>：首先将目标点云数据分为若干格子，并计算每个格子的正态分布参数。</li>
<li><strong>概率计算</strong>：然后将需要匹配的点云数据进行转换，对转换后的点云数据计算各点的概率密度。目标函数为各点概率密度之和。</li>
<li><strong>迭代优化</strong>：使用牛顿优化法法对目标函数进行迭代优化，直到满足收敛条件。</li>
</ul>
<p>由于目标点云数据只需要处理一次，之后使用的都是处理后的均值mu以及协方差矩阵Sigma，并且没有查找最近点的开销，运算速度会比ICP快。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h1 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h1><p>Iterative Closest Point 迭代最近点</p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>ICP的本质是最小二乘法</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.cnblogs.com/21207-iHome/p/8039741.html">NDT（Normal Distributions Transform）算法原理与公式推导</a></li>
<li><a href="https://www.cnblogs.com/sddai/p/6129437.html">ICP算法（Iterative Closest Point迭代最近点算法）</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.yu-xiaoxian.me/2018/04/15/wiki/C-%E6%9C%AF%E8%AF%AD%E4%B8%8E%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于小咸的日志">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/wiki/C-%E6%9C%AF%E8%AF%AD%E4%B8%8E%E6%A6%82%E5%BF%B5/" itemprop="url">C++ 术语与概念</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-15T14:43:16+00:00">
                2018-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Wiki/" itemprop="url" rel="index">
                    <span itemprop="name">Wiki</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++ 是在C语言基础上开发的，一种面向对象编程的语言。C++在C语言基础上封装了类实现了面向对象的功能，封装了函数实现了泛型编程的功能。与C相比具有安全性更高、功能更强的特点。本文以wiki知识库的形式，介绍C++的基本概念和语法规则，并在每个术语旁边配有对应的英文，为初学C++的人提供一份快速查阅的手册。旨在用最简短的文字，介绍清概念以及用法。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="面向对象编程-Object-Oriented-Programming-OOP"><a href="#面向对象编程-Object-Oriented-Programming-OOP" class="headerlink" title="面向对象编程 Object Oriented Programming(OOP)"></a>面向对象编程 Object Oriented Programming(OOP)</h2><h2 id="编译过程：编译-连接"><a href="#编译过程：编译-连接" class="headerlink" title="编译过程：编译+连接"></a>编译过程：编译+连接</h2><h2 id="计算机语言的分类"><a href="#计算机语言的分类" class="headerlink" title="计算机语言的分类"></a>计算机语言的分类</h2><ul>
<li>机器语言：二进制代码</li>
<li>汇编语言：机器语言的简化，直接对地址、内存、寄存器进行操作，汇编代码与机器语言是一一对应的</li>
<li>高级语言：抽象程度更高，需要编译成机器语言</li>
<li>脚本语言：不需要编译</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>关键字</li>
<li>标识符</li>
</ul>
<h1 id="基本数据类型与运算"><a href="#基本数据类型与运算" class="headerlink" title="基本数据类型与运算"></a>基本数据类型与运算</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>基本数据类型：整型int，浮点型float，双精度浮点double，字符char，布尔bool</li>
<li>自定义数据类型：枚举类型，结构体类型，联合体类型，类类型</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li>条件判断：if,while,switch</li>
</ul>
<p>C语言和C++中，所有非零的值都被判定为逻辑真，为零的值才会被判定为逻辑假。</p>
<p>if、while语句中的逻辑判断是分步进行的，比如与运算中，只要前一项为非，不会对后一项进行判断，而是直接跳出判断。</p>
<h2 id="数据的存储与操作"><a href="#数据的存储与操作" class="headerlink" title="数据的存储与操作"></a>数据的存储与操作</h2><p>每个数据都会单独分配内存空间来处理</p>
<p>CPU只是对内存数据进行操作，而不会区分不同的数据类型。区分数据类型并选择不同的操作，是编译器需要完成的工作。</p>
<h1 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 Function"></a>函数 Function</h1><p>函数由参数表和函数体组成，函数在使用前必须先声明，可以之后再定义</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>函数在调用时才分配存储单元</p>
<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>语法规定：传递给函数的实参，与函数形参表中的数据类型一致</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明，此处省略函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);    <span class="comment">//函数引用，因为传递的是值，此处a, b没有被交换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p>语法规定：使用“&amp;”符号定义一个引用，引用必须指向已经存在的对象。函数的形参是一个引用，传递给函数的实参是被引用对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span>&amp; ri = i;    <span class="comment">//ri是i的一个引用</span></span><br></pre></td></tr></table></figure>
<p>函数实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明，此处省略函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">swap</span>(a ,b);    <span class="comment">//函数引用，因为传递的是引用，此处a, b被交换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h3><p>语法定义：传递实参的地址给子函数，子函数的形参表中定义形参为指针类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明，此处省略函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;a, &amp;b);    <span class="comment">//函数引用，传递指针给子函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><h3 id="运行栈"><a href="#运行栈" class="headerlink" title="运行栈"></a>运行栈</h3><p>最后调用的函数总是最先返回，因此可以用栈这种数据结构来保存。运行栈就是专为函数调用设计的数据结构，</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>寄存器中通常会保存两个指针，分别指向栈顶和函数调用发生的位置，来进行函数的调用和返回。</p>
<ul>
<li><strong>栈顶指针</strong>：指向栈顶的地址</li>
<li><strong>帧指针</strong>：指向函数调用时的地址</li>
</ul>
<h2 id="函数的声明与安全性"><a href="#函数的声明与安全性" class="headerlink" title="函数的声明与安全性"></a>函数的声明与安全性</h2><p>C++ 要求函数在使用时先声明返回值类型和参数表，这样可以在编译过程中发现错误，是设计更为合理的编程语言。如果不做声明，在参数传递和参数返回两个过程中，都可能发生错误。</p>
<ul>
<li>参数传递中，有可能把参数类型传错，将整型变量传递给浮点变量，而不做类型转换。</li>
<li>参数返回中，不做声明，有可能用整型方法去获取void类型的函数值，就会读取垃圾数据。</li>
</ul>
<h1 id="类与对象-Class-amp-Object"><a href="#类与对象-Class-amp-Object" class="headerlink" title="类与对象 Class &amp; Object"></a>类与对象 Class &amp; Object</h1><h2 id="构造函数与析构函数-Constructor-and-Destructor"><a href="#构造函数与析构函数-Constructor-and-Destructor" class="headerlink" title="构造函数与析构函数 Constructor and Destructor"></a>构造函数与析构函数 Constructor and Destructor</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>语法定义：函数名没有返回值类型，函数名和类名一致，不允许有返回值列席，不允许有return语句。当没有声明构造函数时，编译器会自动生成默认的构造函数，用于分配类成员的空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point</span>()&#123;&#125;;	<span class="comment">//构造函数声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>除参数表和函数体以外，构造还可以拥有初始化列表，效率比在函数体中赋值要高一些。因为当传递参数是类时，在初始化列表中进行初始化，只需要执行一次复制构造函数。若在函数体中进行初始化，首先需要调用构造函数构造对象，再调用构造函数的赋值运算符进行赋值运算。</p>
<p>语法定义：初始化列表位于参数表和函数体之间，用冒号跟参数表隔开，初始化对象之间用逗号分隔。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">double</span> init_x, <span class="type">double</span> init_y):<span class="built_in">x</span>(init_x),<span class="built_in">y</span>(init_y)&#123;&#125;	<span class="comment">//含初始化列表的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>使用委托构造函数，可以保证代码的一致性，提高代码的复用率，降低修改成本</p>
<p>语法定义：定义构造函数时，可以在初始化列表中使用其他已经声明的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">double</span> init_x, <span class="type">double</span> init_y):<span class="built_in">x</span>(init_x),<span class="built_in">y</span>(init_y)&#123;&#125;	<span class="comment">//含初始化列表的构造函数</span></span><br><span class="line">	<span class="built_in">Point</span>():<span class="built_in">Point</span>(<span class="number">0.0</span>,<span class="number">0.0</span>)&#123;&#125;	<span class="comment">//使用委托构造函数来实现默认构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>语法定义：函数名与类名一致，形参表为const定义的类对象的引用。可以用”=delete”指令隐藏复制构造函数。有两个要点：复制和构造。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">double</span> init_x, <span class="type">double</span> init_y):<span class="built_in">x</span>(init_x),<span class="built_in">y</span>(init_y)&#123;&#125;	<span class="comment">//含初始化列表的构造函数</span></span><br><span class="line">	<span class="built_in">Point</span>():<span class="built_in">Point</span>(<span class="number">0.0</span>,<span class="number">0.0</span>)&#123;&#125;	<span class="comment">//委托构造函数</span></span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p)&#123;&#125;	<span class="comment">//复制构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数在主程序中的使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Point a;	<span class="comment">//默认构造函数被调用</span></span><br><span class="line">	<span class="function">Point <span class="title">b</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;		<span class="comment">//含参数表的构造函数被调用</span></span><br><span class="line">	<span class="function">Point <span class="title">c</span><span class="params">(a)</span></span>;		<span class="comment">//复制构造函数被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>语法定义：函数名在类名前加”~”，不允许有参数表，不允许有返回值列席，不允许有return语句。不定义时，编译器会自动生成析构函数。在对象消亡时，析构函数会被自动调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	<span class="type">double</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">double</span> init_x, <span class="type">double</span> init_y):<span class="built_in">x</span>(init_x),<span class="built_in">y</span>(init_y)&#123;&#125;	<span class="comment">//含初始化列表的构造函数</span></span><br><span class="line">	<span class="built_in">Point</span>():<span class="built_in">Point</span>(<span class="number">0.0</span>,<span class="number">0.0</span>)&#123;&#125;	<span class="comment">//委托构造函数</span></span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p)&#123;&#125;		<span class="comment">//复制构造函数</span></span><br><span class="line">	~<span class="built_in">Point</span>()&#123;&#125;		<span class="comment">//析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组合类"><a href="#组合类" class="headerlink" title="组合类"></a>组合类</h2><ul>
<li><p><strong>组合类的构造函数</strong>：初始化的顺序与类中声名的顺序相同，与初始化列表中的顺序不同，组合类初始化时，会调用两次初始化构造函数，第一次是将实参赋值给形参，第二次是把形参值赋值给组合类中的对象。</p>
</li>
<li><p><strong>前向引用声名</strong>：只声名类的名字而不包含任何细节。</p>
</li>
</ul>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><ul>
<li>事物：</li>
<li>关系：依赖，重数，聚集（组合），泛化</li>
<li>图：</li>
</ul>
<h2 id="特殊类"><a href="#特殊类" class="headerlink" title="特殊类"></a>特殊类</h2><ul>
<li>结构体：在C++中是特殊的类，成员默认是public</li>
<li>联合体：成员共用存储空间，只有一个成员有效，可以使用无名的联合体。</li>
<li>枚举类：类型控制更严格，无法比较不同类的枚举类型；作用域限制在类中，可以使用同样的名字。</li>
</ul>
<h1 id="数据的共享与保护"><a href="#数据的共享与保护" class="headerlink" title="数据的共享与保护"></a>数据的共享与保护</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域由小到大可以分为以下几种：</p>
<ul>
<li>函数原型作用域：只在形参表中存在</li>
<li>局部作用域：又称为块作用域，变量定义所在的最小的一对大括号内</li>
<li>类作用域：</li>
<li>文件作用域：又称为静态作用域</li>
<li>命名空间作用域：</li>
</ul>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>作用域和可见性可能不一致：当内层作用域与外层作用域出现变量重名</p>
<h2 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h2><ul>
<li>静态生存期：文件作用域中定义的变量，或用static声明的变量；如果在函数体内声明静态变量，那么该变量只会初始化一次，在之后对函数的调用过程中，访问的是同一个变量。</li>
<li>动态生存期：与作用域一致，同时消亡；在函数中调用的会随着函数运行栈的消亡而消亡</li>
</ul>
<h2 id="类的静态对象"><a href="#类的静态对象" class="headerlink" title="类的静态对象"></a>类的静态对象</h2><ul>
<li>为所有类的对象共有，可以使用类名直接调用</li>
<li>静态数据：声明在类体重，初始化和定义必须在类体之外</li>
<li>静态函数：无法确定调用对象，不可直接访问对象的非静态变量</li>
</ul>
<h2 id="友元-freind"><a href="#友元-freind" class="headerlink" title="友元: freind"></a>友元: freind</h2><ul>
<li>友元函数：在类中声明，在类外定义，需要把对象当做实参传递给函数</li>
<li>友元类：友元关系式单向的</li>
</ul>
<h2 id="常类型：const"><a href="#常类型：const" class="headerlink" title="常类型：const"></a>常类型：const</h2><ul>
<li><p>常对象：必须初始化，不能被更新</p>
</li>
<li><p>常成员：</p>
<p>  a. 常数据成员</p>
<p>  b. 常函数成员（一种函数重载的判断条件）：承诺不改变数据状态，并由编译器进行检验（bitwise检验）<br><strong>注一</strong>：可使用“mutable” 摆动场，释放非静态成员的bitwise constness 约束，从而使得常函数可以修改这些非静态成员的值。<br><strong>注二</strong>：可使用转型“casting”方法，用non-const函数调用const函数，从而实现代码复用。</p>
</li>
<li><p>常引用：提高参数传递效率的同时，满足安全性的条件</p>
</li>
<li><p>常指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p1;    <span class="comment">//指向整型常量的指针</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> * p2;   <span class="comment">//指向整型常量的指针</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p3;    <span class="comment">//指向整型变量的常量指针</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="多文件结构"><a href="#多文件结构" class="headerlink" title="多文件结构"></a>多文件结构</h2><p>C++工程结构：声明文件、定义文件、使用文件</p>
<ul>
<li>外部变量：文件作用域中定义的变量，默认都是外部变量。使用时需要用extern关键字声明之后，才可以使用</li>
<li>外部函数：</li>
<li>编译预处理：#include, #define, #if #endif #else #elif, #ifdef</li>
</ul>
<h2 id="标准C-库"><a href="#标准C-库" class="headerlink" title="标准C++库"></a>标准C++库</h2><ul>
<li>输入输出类iostream：</li>
<li>容器类与抽象数据类型stl：</li>
<li>存储管理类</li>
<li>算法algorithms：</li>
<li>错误处理</li>
<li>运行环境支持</li>
</ul>
<h1 id="指针和数组-Pointers-amp-Array"><a href="#指针和数组-Pointers-amp-Array" class="headerlink" title="指针和数组 Pointers &amp; Array"></a>指针和数组 Pointers &amp; Array</h1><p>&amp;: 取数据对应的地址，*: 取地址对应的数据</p>
<h2 id="指针的应用场景"><a href="#指针的应用场景" class="headerlink" title="指针的应用场景"></a>指针的应用场景</h2><ul>
<li>动态内存分配，返回值只能是指针</li>
<li>深拷贝：自定义构造函数，为类内的指针属性申请内存空间。</li>
</ul>
<h2 id="指针-Pointers"><a href="#指针-Pointers" class="headerlink" title="指针 Pointers"></a>指针 Pointers</h2><ul>
<li>定义：用于存放地址类型的变量</li>
<li>初始化：指针变量的赋值必须是合法获得的地址,不可用非静态变量去初始化静态指针，空指针：nullptr</li>
<li>指向常量的指针，指针类型的常量</li>
<li>指针的算术运算：+n指向第n个数据的起始位置</li>
<li>指针的关系运算：指向相同类型的指针可以进行关系运算，也可以跟0进行关系运算</li>
</ul>
<h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h2><h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><p>语法定义：类型说明符 + 数组名 + [常量表达式][常量表达式]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array_1[<span class="number">3</span>];		<span class="comment">//一维数组</span></span><br><span class="line"><span class="type">int</span> array_2[<span class="number">3</span>][<span class="number">4</span>];	<span class="comment">//二维数组</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<em>数组名后接的一定是常量表达式，不可以是变量</em></p>
<ul>
<li>初始化：可以只给一部分元素初始值，数组名保存首元素的内存地址，为常量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array_1[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;	<span class="comment">//全部初始化</span></span><br><span class="line"><span class="type">int</span> array_2[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;	<span class="comment">//部分初始化，未初始化部分为0</span></span><br><span class="line"><span class="type">int</span> array_3[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;	<span class="comment">//全部初始化可以不声明数组长度</span></span><br><span class="line"><span class="type">int</span> array_4[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;	<span class="comment">//二维数组初始化可以用大括号隔开 </span></span><br></pre></td></tr></table></figure>
<ul>
<li>传递：数组作为函数参数传递时，直接传递指针</li>
</ul>
<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>语法定义：类型说明符 + 指针运算符 + 数组名 + [常量表达式][常量表达式]</p>
<p>代码实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pa[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>指针数组的用法跟多维数组类似，但是多维数组可以按照一维数组来使用，而指针数组不行。</p>
<h2 id="函数与指针"><a href="#函数与指针" class="headerlink" title="函数与指针"></a>函数与指针</h2><h3 id="指针类型的函数"><a href="#指针类型的函数" class="headerlink" title="指针类型的函数"></a>指针类型的函数</h3><p>语法定义：存储类型 + 数据类型 + *函数名(形参表){函数体}</p>
<p>代码实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func_1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：返回值必须是在主调函数中合法有效的地址，合法的地址包括</p>
<ul>
<li>数组作为参数传递给函数</li>
<li>子函数中动态分配的地址</li>
</ul>
<h3 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h3><p>语法定义：存储类型 + 数据类型 + (*函数名)(形参表){函数体}</p>
<p>典型用途：函数回调</p>
<p>代码实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义主调函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compute</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>(*func)(<span class="type">int</span>, <span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> <span class="built_in">func</span>(a,b);&#125;</span><br><span class="line"><span class="comment">//定义求最值的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> ((a&gt;b)?a:b);&#125;</span><br><span class="line"><span class="comment">//定义求和函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="built_in">compute</span>(a, b, &amp;max);	<span class="comment">//求最大值</span></span><br><span class="line">	<span class="built_in">compute</span>(a, b, &amp;sum);	<span class="comment">//求和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象与指针"><a href="#对象与指针" class="headerlink" title="对象与指针"></a>对象与指针</h2><ul>
<li>使用语法：对象指针 + “-&gt;” + 成员</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point p;</span><br><span class="line">Point* ptr;		<span class="comment">//定义对象指针</span></span><br><span class="line">ptr = &amp;p;</span><br><span class="line">p.<span class="built_in">getx</span>();		<span class="comment">//使用对象调用成员函数</span></span><br><span class="line">ptr-&gt;<span class="built_in">getx</span>();	<span class="comment">//使用对象指针调用成员函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>this指针：类对象隐含的指针</li>
</ul>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><ul>
<li>使用语法：new 类型名T（初始化参数列表）；delete 指针标识符；delet[] 数组标识符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point *ptr = <span class="keyword">new</span> <span class="built_in">Point</span>(<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line"><span class="keyword">delete</span> ptr;		<span class="comment">//删除对象，但不删除指针</span></span><br><span class="line">ptr = <span class="keyword">new</span> <span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意事项：分配和释放一定要配合使用</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul>
<li>unique_ptr ：不允许多个指针共享资源，可以用标准库中的move函数转移指针</li>
<li>shared_ptr ：多个指针共享资源</li>
<li>weak_ptr ：可复制shared_ptr，但其构造或者释放对资源不产生影响</li>
</ul>
<h2 id="对象的复制与移动"><a href="#对象的复制与移动" class="headerlink" title="对象的复制与移动"></a>对象的复制与移动</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul>
<li>浅层复制：数据成员的一一对应</li>
<li>深层复制：在复制对象数据成员的基础上，复制指针指向的动态内存空间</li>
</ul>
<h3 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h3><p>语法定义：函数名与类名一致，参数表为类对象的右值引用</p>
<p>代码实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IntNum</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">IntNum</span>(IntNum &amp;&amp; n): <span class="built_in">xptr</span>(n.xptr)&#123;</span><br><span class="line">		n.xptr = <span class="literal">nullptr</span>;		<span class="comment">//将原始值赋值为nullptr</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>C风格字符串：字符串数组，最后一位用”\0”结尾</li>
<li>C++风格：string 类</li>
</ul>
<h1 id="继承-Inherit"><a href="#继承-Inherit" class="headerlink" title="继承 Inherit"></a>继承 Inherit</h1><h2 id="基本概念和语法"><a href="#基本概念和语法" class="headerlink" title="基本概念和语法"></a>基本概念和语法</h2><p>语法定义： class + 派生类名 + : + 继承方式 + 基类名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedPublic</span> : <span class="keyword">public</span> Base &#123;&#125;         <span class="comment">//基类Base的派生类（公有继承）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedPrivate</span> : <span class="keyword">private</span> Base &#123;&#125;       <span class="comment">//基类Base的派生类（私有继承）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedProtected</span> : <span class="keyword">protected</span> Base &#123;&#125;   <span class="comment">//基类Base的派生类（保护继承）</span></span><br></pre></td></tr></table></figure>
<h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><p>类成员的三种访问权限与三种继承方式是对应的，分别限定了类成员对于类对象、子类成员和子类对象的可见性。如果需要基类的某个成员对其派生类可见，但是对其对象不可见，那么就采用保护的可见性。</p>
<h3 id="公有继承"><a href="#公有继承" class="headerlink" title="公有继承"></a>公有继承</h3><p>公有继承不改变基类成员的可见性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员类型</th>
<th>基类对象</th>
<th>派生类成员</th>
<th>派生类对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
</tr>
<tr>
<td>protected</td>
<td>不可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>private</td>
<td>不可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
</tbody>
</table>
</div>
<h3 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h3><p>私有继承将基类成员全部转变为派生类的私有成员</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员类型</th>
<th>基类对象</th>
<th>派生类成员</th>
<th>派生类对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>protected</td>
<td>不可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>private</td>
<td>不可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
</tbody>
</table>
</div>
<h3 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h3><p>保护继承将基类的共有成员转变为保护成员，其他成员的可见性不变</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员类型</th>
<th>基类对象</th>
<th>派生类成员</th>
<th>派生类对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>protected</td>
<td>不可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>private</td>
<td>不可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
</tbody>
</table>
</div>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>派生类对象可以转换为基类对象。</p>
<p><strong>注意</strong>：不要定义继承来的非虚函数</p>
<h2 id="派生类的构造和析构函数"><a href="#派生类的构造和析构函数" class="headerlink" title="派生类的构造和析构函数"></a>派生类的构造和析构函数</h2><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>语法定义：派生类名::派生类名(基类所需的形参，本类成员所需的形参):<br>基类名(参数表), 本类成员初始化列表</p>
<p>可以用using直接使用基类的构造函数。</p>
<p>代码示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;	<span class="comment">//基类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B&#123;	<span class="comment">//派生类C</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C</span>(<span class="type">int</span> i, <span class="type">int</span> j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//派生类的构造函数</span></span><br><span class="line">C::<span class="built_in">C</span>(<span class="type">int</span> i,<span class="type">int</span> j): <span class="built_in">B</span>(i), <span class="built_in">c</span>(j)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复制构造函数-1"><a href="#复制构造函数-1" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>语法定义：派生类名::派生类名(const 派生类名 &amp;派生对象):<br>基类名(派生对象)</p>
<p>原理在于派生对象可以直接转换为基类对象</p>
<p>程序实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C::<span class="built_in">C</span>(<span class="type">const</span> &amp;c1):<span class="built_in">B</span>(c1)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="析构函数-1"><a href="#析构函数-1" class="headerlink" title="析构函数"></a>析构函数</h3><p>语法定义：派生类名::~派生类名()</p>
<p>并不需要显式地调用基类的析构函数</p>
<p>程序实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C::~<span class="built_in">C</span>()&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问基类的成员"><a href="#访问基类的成员" class="headerlink" title="访问基类的成员"></a>访问基类的成员</h2><h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><p>当同名成员被多次定义的时候，出现了二义性，可以使用类名来限定。</p>
<p>当派生类从多个基类派生，而这些基类又有共同基类时，二义性会导致程序的冗余，甚至引起混淆或错误。</p>
<h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><p>慎用虚基类</p>
<p>语法定义：使用virtual调用</p>
<p>代码实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数：最远派生类（建立对象时使用的类）给虚基类传递函数。</p>
<h1 id="多态性-Polymorphism"><a href="#多态性-Polymorphism" class="headerlink" title="多态性 Polymorphism"></a>多态性 Polymorphism</h1><ul>
<li>编译多态性：重载运算符, 重载函数</li>
<li>运行多态性：虚函数</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则"></a>重载规则</h3><p>运算符的重载不改变运算符的优先级，并且只能重载C++中已经包含的运算符</p>
<p>不能够重载的运算符： “.”, “.*”, “::”, “?:”</p>
<h3 id="双目运算符重载为成员函数"><a href="#双目运算符重载为成员函数" class="headerlink" title="双目运算符重载为成员函数"></a>双目运算符重载为成员函数</h3><p>语法定义：函数类型 operator 运算符（形参）</p>
<p>参数个数 = 原操作数 - 1</p>
<p>代码实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c2)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Complex</span>(real+c2.real, img+c2.img);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单目运算符重载为成员函数"><a href="#单目运算符重载为成员函数" class="headerlink" title="单目运算符重载为成员函数"></a>单目运算符重载为成员函数</h3><p>语法定义：</p>
<ul>
<li><p>前置：函数类型 &amp;operator 运算符()</p>
</li>
<li><p>后置：函数类型 operator 运算符(int)</p>
</li>
</ul>
<p>代码实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clock&amp; <span class="keyword">operator</span> ++ ();	<span class="comment">//前置运算符</span></span><br><span class="line">Clock <span class="keyword">operator</span> ++ (<span class="number">0</span>);	<span class="comment">//后置运算符</span></span><br></pre></td></tr></table></figure>
<h3 id="重载操作符为非成员函数"><a href="#重载操作符为非成员函数" class="headerlink" title="重载操作符为非成员函数"></a>重载操作符为非成员函数</h3><p>语法定义：需要列出所有的操作数，前置、后置单目运算符需要添加一个int</p>
<p>代码实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c1, <span class="type">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c1.real+c2.real, c1.imag+c2.imag); </span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex &amp;c1, <span class="type">const</span> Complex &amp;c2)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Complex</span>(c1.real-c2.real, c1.imag-c2.imag); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Complex &amp;c)&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; c.real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数"></a>虚函数</h3><p>语法定义：virtual 函数类型 函数名(形参表)</p>
<p>虚函数不可以是静态，构造函数不可以是虚函数</p>
<p>代码实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vitual <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>语法定义：与虚函数的定义一样</p>
<p>使用虚析构函数，可以保证动态申请的内存空间能够被释放。否则，基类指针指向的派生类对象消亡时，只会调用基类的析构函数。</p>
<h3 id="虚表与动态绑定"><a href="#虚表与动态绑定" class="headerlink" title="虚表与动态绑定"></a>虚表与动态绑定</h3><p>每个多态类有一个虚表，虚表中有当前各个虚函数的入口地址</p>
<p>每个对象有一个指向当前虚表的指针</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>纯虚函数: virtual 函数类型 函数名(参数表) = 0</p>
<p>包含纯虚函数的类为抽象类，不能够构造对象</p>
<h2 id="显示函数覆盖-overriide"><a href="#显示函数覆盖-overriide" class="headerlink" title="显示函数覆盖 overriide"></a>显示函数覆盖 overriide</h2><h2 id="不允许被继承-final"><a href="#不允许被继承-final" class="headerlink" title="不允许被继承 final"></a>不允许被继承 final</h2><p>语法定义： class 对象名 final;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clase Base1 <span class="keyword">final</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模板-Template"><a href="#模板-Template" class="headerlink" title="模板 Template"></a>模板 Template</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>语法定义：template&lt;模板参数表&gt; 函数定义<br>模板参数表：typename 或者 class</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">abs</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &lt; <span class="number">0</span>? -x:x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>语法定义：template&lt;模板参数表&gt; 类定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(T n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性群体"><a href="#线性群体" class="headerlink" title="线性群体"></a>线性群体</h2><h3 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><strong>数组类模板特点</strong>：</p>
<ul>
<li>存储空间在内存上连续，可以直接访问数组成员，访问开销为O(1)</li>
</ul>
<p><strong>数组基本功能</strong>：</p>
<ul>
<li>构造函数：构造函数、复制构造函数、析构函数</li>
<li>重载操作符：[], *, =</li>
<li>数组操作：修改数组大小、取数组大小</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  <span class="comment">//数组类模板定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T * list;        <span class="comment">//用于存放动态分配的数组内存首地址</span></span><br><span class="line">	<span class="type">int</span> size;       <span class="comment">//数组大小（元素个数）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Array</span>(<span class="type">int</span> sz = <span class="number">50</span>);     <span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Array</span>(<span class="type">const</span> Array&lt;T&gt; &amp;a);   <span class="comment">//复制构造函数</span></span><br><span class="line">	~<span class="built_in">Array</span>();           <span class="comment">//析构函数</span></span><br><span class="line">	Array&lt;T&gt; &amp; <span class="keyword">operator</span> = (<span class="type">const</span> Array&lt;T&gt; &amp;rhs);    <span class="comment">//重载&quot;=&quot;，赋值运算符的返回值为数组的引用</span></span><br><span class="line">	T &amp; <span class="keyword">operator</span> [] (<span class="type">int</span> i); <span class="comment">//重载&quot;[]&quot;</span></span><br><span class="line">	<span class="type">const</span> T &amp; <span class="keyword">operator</span> [] (<span class="type">int</span> i) <span class="type">const</span>;     <span class="comment">//重载&quot;[]&quot;常函数</span></span><br><span class="line">	<span class="keyword">operator</span> T * ();        <span class="comment">//重载到T*类型的转换，指针函数不要求声明返回值类型</span></span><br><span class="line">	<span class="keyword">operator</span> <span class="type">const</span> T * () <span class="type">const</span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">//取数组的大小</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> sz)</span></span>;        <span class="comment">//修改数组的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h3><h4 id="节点-Node"><a href="#节点-Node" class="headerlink" title="节点 Node"></a>节点 Node</h4><p>节点是顺序访问的基本元素</p>
<p><strong>节点特点</strong>：</p>
<p><strong>节点基本功能</strong>：</p>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node&lt;T&gt; *next;  <span class="comment">//指向后继结点的指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	T data; <span class="comment">//数据域</span></span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">const</span> T &amp;data, Node&lt;T&gt; *next = <span class="number">0</span>);    <span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insertAfter</span><span class="params">(Node&lt;T&gt; *p)</span></span>;   <span class="comment">//在本结点之后插入一个同类结点p </span></span><br><span class="line">	<span class="function">Node&lt;T&gt; *<span class="title">deleteAfter</span><span class="params">()</span></span>; <span class="comment">//删除本结点的后继结点，并返回其地址</span></span><br><span class="line">	<span class="function">Node&lt;T&gt; *<span class="title">nextNode</span><span class="params">()</span></span>;            <span class="comment">//获取后继结点的地址</span></span><br><span class="line">	<span class="function"><span class="type">const</span> Node&lt;T&gt; *<span class="title">nextNode</span><span class="params">()</span> <span class="type">const</span></span>;     <span class="comment">//获取后继结点的地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="链表-List"><a href="#链表-List" class="headerlink" title="链表 List"></a>链表 List</h4><p><strong>链表特点</strong>：</p>
<ul>
<li>访问必须从第一个对象开始</li>
</ul>
<p><strong>链表基本功能</strong>：</p>
<ul>
<li>构造函数：构造函数、复制构造函数、析构函数</li>
<li>操作符重载：</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//数据成员：</span></span><br><span class="line">	Node&lt;T&gt; *front, *rear;  <span class="comment">//表头和表尾指针</span></span><br><span class="line">	Node&lt;T&gt; *prevPtr, *currPtr;   <span class="comment">//记录表当前遍历位置的指针，由插入和删除操作更新</span></span><br><span class="line">	<span class="type">int</span> size;   <span class="comment">//表中的元素个数</span></span><br><span class="line">	<span class="type">int</span> position;   <span class="comment">//当前元素在表中的位置序号。由函数reset使用</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">//函数成员：</span></span><br><span class="line">					<span class="comment">//生成新结点，数据域为item，指针域为ptrNext</span></span><br><span class="line">	<span class="function">Node&lt;T&gt; *<span class="title">newNode</span><span class="params">(<span class="type">const</span> T &amp;item, Node&lt;T&gt; *ptrNext = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放结点</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">freeNode</span><span class="params">(Node&lt;T&gt; *p)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将链表L 拷贝到当前表（假设当前表为空）。</span></span><br><span class="line">	<span class="comment">//被拷贝构造函数、operator = 调用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(<span class="type">const</span> LinkedList&lt;T&gt;&amp; L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LinkedList</span>();   <span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">LinkedList</span>(<span class="type">const</span> LinkedList&lt;T&gt; &amp;L);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">	~<span class="built_in">LinkedList</span>();  <span class="comment">//析构函数</span></span><br><span class="line">	LinkedList&lt;T&gt; &amp; <span class="keyword">operator</span> = (<span class="type">const</span> LinkedList&lt;T&gt; &amp;L); <span class="comment">//重载赋值运算符</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">//返回链表中元素个数</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//链表是否为空</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> pos = <span class="number">0</span>)</span></span>;<span class="comment">//初始化游标的位置</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span></span>;    <span class="comment">//使游标移动到下一个结点</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">endOfList</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//游标是否到了链尾</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">currentPosition</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">//返回游标当前的位置</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insertFront</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;    <span class="comment">//在表头插入结点</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insertRear</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;     <span class="comment">//在表尾添加结点</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insertAt</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;       <span class="comment">//在当前结点之前插入结点</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insertAfter</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;    <span class="comment">//在当前结点之后插入结点</span></span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">deleteFront</span><span class="params">()</span></span>;    <span class="comment">//删除头结点</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">deleteCurrent</span><span class="params">()</span></span>;   <span class="comment">//删除当前结点</span></span><br><span class="line"></span><br><span class="line">	<span class="function">T&amp; <span class="title">data</span><span class="params">()</span></span>;              <span class="comment">//返回对当前结点成员数据的引用</span></span><br><span class="line">	<span class="function"><span class="type">const</span> T&amp; <span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//返回对当前结点成员数据的常引用</span></span><br><span class="line"></span><br><span class="line">							 <span class="comment">//清空链表：释放所有结点的内存空间。被析构函数、operator= 调用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h3><p><strong>栈特点</strong>：</p>
<ul>
<li>只能从一端存储和读取数据</li>
</ul>
<p><strong>栈基本功能</strong>：</p>
<ul>
<li>构造函数：</li>
<li>栈操作函数</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> SIZE = <span class="number">50</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Stack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T list[SIZE];</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Stack</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;</span><br><span class="line">	<span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">const</span> T &amp;<span class="title">peek</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列-Quene"><a href="#队列-Quene" class="headerlink" title="队列 Quene"></a>队列 Quene</h3><p>队列特点：</p>
<ul>
<li>只能从有一段存储数据，从另一端删除数据</li>
</ul>
<p>队列基本功能：</p>
<ul>
<li>构造函数：</li>
<li>队列操作（有修改的）：入队、出队、清空</li>
<li>队列操作（无修改的）：访问队首元素、求队列长度、判断队列是否为空、判断队列是否满</li>
</ul>
<p>代码实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> SIZE = <span class="number">50</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Queue &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> front, rear, count; <span class="comment">//队头指针、队尾指针、元素个数</span></span><br><span class="line">	T list[SIZE];   <span class="comment">//队列元素数组</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Queue</span>();          <span class="comment">//构造函数，初始化队头指针、队尾指针、元素个数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>; <span class="comment">//新元素入队</span></span><br><span class="line">	<span class="function">T <span class="title">remove</span><span class="params">()</span></span>; <span class="comment">//元素出队</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;   <span class="comment">//清空队列</span></span><br><span class="line">	<span class="function"><span class="type">const</span> T &amp;<span class="title">getFront</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">//访问队首元素</span></span><br><span class="line">								<span class="comment">//测试队列状态</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//求队列长度</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//判断队列空否</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//判断队列满否</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h3><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>排序分为内排序、外排序。内循环全部在内存中进行循环，外排序需要分批次从硬盘中读取数据。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>每次将待排序元素与已排序数组进行比较，并插入到合适位置上去。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>在未排序队列中选择最小的数据，放在未排序队列的末尾</p>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><p>相邻元素两两比较，如果不合适，则进行交换</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>什么是堆排序？</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>将整个数组遍历一遍</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>折半查找</p>
<h1 id="泛型程序设计与STL标准模板库"><a href="#泛型程序设计与STL标准模板库" class="headerlink" title="泛型程序设计与STL标准模板库"></a>泛型程序设计与STL标准模板库</h1><h2 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h2><p>泛型程序设计，是为了提高代码复用率的方法。在解决同一类问题的过程中，抽象出一种概念，根据这种概念设计通用的算法。。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>概念：具备一定功能的数据模型</li>
<li>模型：符合一个概念的数据类型，称为该概念的模型</li>
</ul>
<p>使用概念作为模板参数名，设计对应的类模板和函数模板，从而可以解决同一类问题。</p>
<h2 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h2><h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><p>迭代器是算法和容器的桥梁，将函数对象作为算法的参数。</p>
<ul>
<li>迭代器：泛型指针，提供顺序访问容器对象的方法</li>
<li>容器：容纳、包含一组元素的对象，并且通过适配器实现基本容器的特殊化</li>
<li>算法：需要包含头文件，提供了70多种算法</li>
<li>函数对象：行为类似函数的对象，任何普通函数以及重载”()”运算符的类对象都可以作为函数对象使用</li>
</ul>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="输入流迭代器"><a href="#输入流迭代器" class="headerlink" title="输入流迭代器"></a>输入流迭代器</h4><p>用来从序列中读取数据</p>
<p><strong>用法</strong>：</p>
<ul>
<li>以输入流为参数构造</li>
<li>可以使用*(p++)获取下一个输入的元素</li>
</ul>
<p>代码实例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">istream_iterator</span>&lt;<span class="type">double</span>&gt;(cin)</span><br></pre></td></tr></table></figure></p>
<h4 id="输出流迭代器"><a href="#输出流迭代器" class="headerlink" title="输出流迭代器"></a>输出流迭代器</h4><p>用来向序列中写入数据</p>
<p><strong>用法</strong>：</p>
<ul>
<li>以输出流为参数构造</li>
<li>可以使用*(p++) = x，将x输出到输出流</li>
</ul>
<p>代码实例<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout,<span class="string">&quot;\t&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="前向迭代器"><a href="#前向迭代器" class="headerlink" title="前向迭代器"></a>前向迭代器</h4><p>既是输入流迭代器也是输出流迭代器，可以对序列进行单向遍历</p>
<h4 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h4><p>与前向迭代器类似，不过可以在两个方向遍历数据</p>
<h4 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h4><p>与双向迭代器类似，但是可以在任意位置进行跳转。vector容器的迭代器就是随机访问迭代器。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>根据组织方式，可分为：顺序容器、关联容器<br>根据访问方式，可分为：可逆容器（又可衍生出随机访问容器的概念）、不可逆容器</p>
<p>通用接口：</p>
<ul>
<li>默认构造函数</li>
<li>关系运算符</li>
<li>begin(),end()</li>
<li>clear()</li>
<li>empty()</li>
<li>size()</li>
<li>swap()</li>
</ul>
<h4 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h4><p>举例：向量，双端队列，列表，单向链表，数组</p>
<p>通用接口：</p>
<ul>
<li>asign()</li>
<li>insert()</li>
<li>resize()</li>
</ul>
<p>向量(vector):</p>
<ul>
<li>可扩展的数组</li>
<li>尾部插入比较快，中间插入比较慢</li>
</ul>
<p>双端队列(deque):</p>
<ul>
<li>尾部和头部插入较快，中间插入较慢</li>
<li>随机访问比向量慢</li>
</ul>
<p>列表(List)：</p>
<ul>
<li>任意位置插入和删除很快</li>
<li>不支持随机访问</li>
</ul>
<p>数组(array)：</p>
<ul>
<li>对内部数组的封装</li>
</ul>
<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4><p>特点：每个容器都有key，可根据key进行高效查找<br>分类：</p>
<ul>
<li>按照键对应的元素多少，可分为单重关联容器和多重关联容器</li>
<li>按照类型参数的多少，可分为简单关联容器和二元关联容器<br>举例：set,multiset,map,multimap<br>通用接口：</li>
<li>insert()</li>
<li>erase()</li>
<li>find()</li>
<li>lower_bound(),upper_bound(),equal_range()</li>
<li>count()</li>
</ul>
<p>集合(set):</p>
<ul>
<li>key即是元素本身</li>
</ul>
<p>映射(map):</p>
<ul>
<li>元素是由键和附加数据组成的二元组pair<type,type></li>
<li>可以使用下标运算</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; s;   <span class="comment">//用来存储字母出现次数的映射</span></span><br><span class="line">    <span class="type">char</span> c;     <span class="comment">//存储输入字符</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      cin &gt;&gt; c; <span class="comment">//输入下一个字符</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))&#123; <span class="comment">//判断是否是字母</span></span><br><span class="line">          c = <span class="built_in">tolower</span>(c); <span class="comment">//将字母转换为小写</span></span><br><span class="line">          s[c]++;      <span class="comment">//将该字母的出现频率加1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (c != <span class="string">&#x27;.&#x27;</span>); <span class="comment">//碰到“.”则结束输入</span></span><br><span class="line">    <span class="comment">//输出每个字母出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多重集合(multiset):</p>
<ul>
<li>允许有重复元素</li>
</ul>
<p>多重映射(multimap):</p>
<ul>
<li>一个键有多个附加数据</li>
</ul>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h1 id="流类库与输入输出"><a href="#流类库与输入输出" class="headerlink" title="流类库与输入输出"></a>流类库与输入输出</h1><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常：可以预测但是无法避免的错误。<br>使用独立异常处理模块的原因：1.使得程序整体逻辑连贯；2.小的功能模块没有权限处理错误；</p>
<h2 id="异常处理语法"><a href="#异常处理语法" class="headerlink" title="异常处理语法"></a>异常处理语法</h2><p>throw 块<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span>: 抛出异常</span><br></pre></td></tr></table></figure><br>try 块<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>: 所有可能抛出异常的语句，在<span class="keyword">try</span>块中运行，一旦抛出异常，就中断运行</span><br><span class="line"><span class="keyword">catch</span>: 捕获异常</span><br></pre></td></tr></table></figure><br><strong>注</strong>：可在函数声明同时，声明异常类型，方便处理<br>程序抛掷A,B,C,D类型的异常<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A,B,C,D)</span></span>;</span><br></pre></td></tr></table></figure><br>函数抛掷任意类型的异常<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>函数不抛掷异常<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>异常处理机制会自动析构try块中构造的对象</p>
<h2 id="标准异常类"><a href="#标准异常类" class="headerlink" title="标准异常类"></a>标准异常类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exception</span><br><span class="line">	|-logic_error: 可以在程序中被预先检测出的异常</span><br><span class="line">		|-invalid_argument:</span><br><span class="line">		|-domain_error:</span><br><span class="line">	|-runtime_error: 难以被预先检测出的异常</span><br></pre></td></tr></table></figure>
<h2 id="异常安全性问题"><a href="#异常安全性问题" class="headerlink" title="异常安全性问题"></a>异常安全性问题</h2><p>异常安全性：异常发生时，既不泄露资源，也不能使任何对象陷入非法的状态。<br>原则：不抛掷异常是异常安全的基础<br>技巧：</p>
<ul>
<li>swap()函数一定不会抛出异常；</li>
<li>析构函数尽量不要抛出异常，否则在捕获异常时，析构栈上的对象，如果抛出异常，就会调用terminate函数；</li>
<li>在抛出异常前，将函数中动态申请的内存释放（过于繁琐）；</li>
<li>尽量使用对象；</li>
<li>使用智能指针auto_ptr指向动态申请的地址，那么当异常被捕获时，会自动析构智能指针，也就释放了动态申请的内存；</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.yu-xiaoxian.me/2017/08/05/theory/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E4%BB%8EPC%E4%B8%8B%E8%BD%BD%E5%88%B0MCU%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于小咸的日志">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/05/theory/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E4%BB%8EPC%E4%B8%8B%E8%BD%BD%E5%88%B0MCU%E7%9A%84/" itemprop="url">程序是怎样从PC下载到MCU的</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-05T14:43:16+00:00">
                2017-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>单片机程序一般用C编写，从程序编写到程序运行，要通过两个步骤：编译和烧写。编译是将C编写的单片机程序，编译成单片机可以识别的二进制代码。烧写是把编译好的二进制文件，通过烧录程序或者硬件，存储到单片机的ROM内存中。通常这两步都有专业软件来完成，对开发者是不可见的。但为了更加高效地开发单片机程序，我们有必要深入地了解编译和烧写过程。</p>
<h2 id="C程序的编译"><a href="#C程序的编译" class="headerlink" title="C程序的编译"></a>C程序的编译</h2><p>开发单片机一定会接触Keil C51，它是一款强大的51单片机集成开发环境(IDE)。51单片机虽然支持同一套指令集，但是由于各公司生产的单片机在内存、架构上都有区别，因此不能共用一套代码。而Keil C51集成了多种单片机的型号，可以针对不同的单片机编译对应的二进制文件。</p>
<h2 id="二进制文件的烧写"><a href="#二进制文件的烧写" class="headerlink" title="二进制文件的烧写"></a>二进制文件的烧写</h2><p>编译后的二进制文件，并不能直接写到单片机的ROM中，还需要通过串口进行传输，一般有以下几种方法：</p>
<ol>
<li><p>把单片机当做一个ROM芯片，早期的单片机都是如此。将单片机放在通用编程上编程时，就像给28C256这样的ROM中写程序的过程一样。只是不同的单片机使用的端口，编程用的时序不一样。</p>
</li>
<li><p>像AT89S52或AVR单片机一样，在单片机上有SPI接口，这时用专用的下载线将程序烧写到单片机中。这时不同的是，单片机的CPU除了执行单片机本身的指令之外，还能执行对ROM进行操作的特殊指令，如ROM擦除、烧写和校验指令。在编程ROM时，下载线先通过传输这些指令给CPU执行(擦除ROM、读入数据、烧写ROM、和校验ROM)，这样完成对单片机的ROM的烧写。此外，现在普遍使用的JTAG仿真器也是这样，单片机的CPU能执行JTAG的特殊指令，完成对ROM的烧写操作。</p>
</li>
<li><p>引导程序，即单片机中已经存在了一个烧写程序。启动单片机时首先运行这程序，程序判断端口状态，如果符合“要烧写ROM”的状态存在，就从某个端口(串口、SPI等等)读取数据，然后写入到单片机的ROM中。如果没有“要烧写ROM”的状态，就转到用户的程序开始执行。像AVR单片机的bootloader方式、STC的串口下载方式，还有其他单片机的串口编程等等都是这样。</p>
</li>
</ol>
<h3 id="STC单片机的烧写流程"><a href="#STC单片机的烧写流程" class="headerlink" title="STC单片机的烧写流程"></a>STC单片机的烧写流程</h3><p>其中“检测P3.0有没有合法下载命令流”，指的是为ISP_TRIG寄存器赋值的命令。当为ISP_TRIG赋0x46H和0xB9H时，ISP读写功能被触发，可以对程序寄存器进行进一步的读写，从而控制FLASH的读写。具体的实现方案可以参考Github上的<a href="https://github.com/laborer/stcflash">stcflash</a>项目。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yu Xiaoxian</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src=""></script>
  


  

  

</body>
</html>
