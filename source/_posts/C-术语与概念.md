---
title: C++ 术语与概念
tags:
  - C++
categories:
  - Wiki
date: 2018-04-15 14:43:16
---

# 基本概念

## 编译过程：编译+连接

## 计算机语言的分类

- 汇编语言

- 高级语言

- 脚本语言

## 分类

- 关键字

- 标识符

# 基本数据类型与运算

## 数据类型

- 基本数据类型：整型int，浮点型float，双精度浮点double，字符char，布尔bool

- 自定义数据类型：枚举类型，结构体类型，联合体类型，类类型

## 流程控制

- 条件判断：if,while,switch

# 函数 Function

参数表和函数体。

## 参数传递

函数在调用时才分配存储单元

### 值传递

语法规定：

函数实例：

```c_cpp
//函数声明，此处省略函数定义
void swap(int a, int b){}

int main(){
    int a, b;
    swap(a, b);    //函数引用，因为传递的是值，此处a, b没有被交换

    return 0;
}
```

### 引用传递

语法规定：

函数实例：

```c_cpp
//函数声明，此处省略函数定义
void swap(int& a, int& b){}

int main(){
    int a, b;
    swap(a ,b);    //函数引用，因为传递的是引用，此处a, b被交换

    return 0;
}
```

# 类与对象 Class & Object

## 构造函数与析构函数

- **初始化列表**：在参数表和函数体之间，构造还可以拥有初始化列表，效率比在函数体中赋值要高一些。因为当传递参数是类时，在初始化列表中进行初始化，只需要执行一次复制构造函数。

- **委托构造函数**：代码的一致性

- **复制构造函数**：函数名与类名一致，形参表为const定义的类对象。可以用"=delete"指令隐藏构造函数。有两个要点：复制和构造。

- **析构函数**：

## 组合类

- **组合类的构造函数**：初始化的顺序与类中声名的顺序相同，与初始化列表中的顺序不同，组合类初始化时，会调用两次初始化构造函数，第一次是将实参赋值给形参，第二次是把形参值赋值给组合类中的对象。

- **前向引用声名**：只声名类的名字而不包含任何细节。

## UML

- 事物：

- 关系：依赖，重数，聚集（组合），泛化

- 图：

## 特殊类

- 结构体：在C++中是特殊的类，成员默认是public

- 联合体：成员共用存储空间，只有一个成员有效，可以使用无名的联合体。

- 枚举类：类型控制更严格，无法比较不同类的枚举类型；作用域限制在类中，可以使用同样的名字。



# 数据的共享与保护

## 作用域

作用域由小到大可以分为以下几种：

- 函数原型作用域：只在形参表中存在

- 局部作用域：又称为块作用域，变量定义所在的最小的一对大括号内

- 类作用域：

- 文件作用域：又称为静态作用域

- 命名空间作用域：

## 可见性

作用域和可见性可能不一致：当内层作用域与外层作用域出现变量重名

## 生存期

- 静态生存期：文件作用域中定义的变量，或用static声明的变量，初始化只进行一次

- 动态生存期：与作用域一致，同时消亡

## 类的静态对象

- 为所有类共有

- 声明在类体重，初始化和定义在类体之外

- 静态函数：无法确定调用对象，不可直接访问对象的非静态变量

## 友元: freind

- 友元函数：在类中声明，在类外定义，需要把对象当做实参传递给函数

- 友元类：友元关系式单向的

## 常类型：const

- 常对象：必须初始化，不能被更新

- 常成员：

	a. 常数据成员
	
	b. 常函数成员（一种函数重载的判断条件）：承诺不改变数据状态，并由编译器进行检验

- 常引用：提高参数传递效率的同时，满足安全性的条件

- 常指针

## 多文件结构

C++工程结构：声明文件、定义文件、使用文件

- 外部变量：文件作用域中定义的变量，默认都是外部变量。使用时需要用extern关键字声明之后，才可以使用

- 外部函数：

- 编译预处理：#include, #define, #if #endif #else #elif, #ifdef

## 标准C++库

- 输入输出类iostream：

- 容器类与抽象数据类型stl：

- 存储管理类

- 算法algorithms：

- 错误处理

- 运行环境支持


# 指针和数组 Pointers & Array

&: 取数据对应的地址，*: 取地址对应的数据

## 指针的应用场景

- 动态内存分配，返回值只能是指针

- 深拷贝：自定义构造函数，为类内的指针属性申请内存空间。

## 指针

- 定义：用于存放地址类型的变量

- 初始化：指针变量的赋值必须是合法获得的地址,不可用非静态变量去初始化静态指针，空指针：nullptr

- 指向常量的指针，指针类型的常量

- 指针的算术运算：+n指向第n个数据的起始位置

- 指针的关系运算：指向相同类型的指针可以进行关系运算，也可以跟0进行关系运算

## 数组

- 定义：类型说明符 数组名[常量表达式][常量表达式]

- 初始化：可以只给一部分元素初始值，数组名保存首元素的内存地址，为常量

- 传递：数组作为函数参数传递时，直接传递指针

- 指针数组：

## 函数指针

- 指针类型的函数：返回值为指针。 不能把局部地址返回给主调函数

- 指向函数的指针：用于函数回调

## 对象指针

- 使用语法：Point* ptr;ptr->getx();

- this指针：类对象隐含的指针

## 动态内存分配

- 使用语法：new 类型名T（初始化参数列表）；delete 指针标识符；delet[] 数组标识符

- 注意事项：分配和释放一定要配合使用

## 智能指针

- unique_ptr ：不允许多个指针共享资源，可以用标准库中的move函数转移指针

- shared_ptr ：多个指针共享资源

- weak_ptr ：可复制shared_ptr，但其构造或者释放对资源不产生影响

## 对象的复制与移动

### 复制

- 浅层复制：数据成员的一一对应

- 深层复制：指针指向的动态内存空间

### 移动构造

将原始值赋值为nullptr


## 字符串

- C风格字符串：字符串数组

- C++风格：string 类