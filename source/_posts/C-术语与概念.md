---
title: C++ 术语与概念
tags:
  - C++
categories:
  - Wiki
date: 2018-04-15 14:43:16

updated:: 2018-04-25 14:40:16
---

C++ 是在C语言基础上开发的，面向对象编程的语言。与C相比，具有安全性更高、功能更强的特点。本文以wiki知识库的形式，介绍C++的基本概念和语法规则，并在每个术语旁边配有对应的英文，为初学C++的人提供一份快速查阅的手册。

---

# 基本概念

## 面向对象编程 Object Oriented Programming(OOP)

## 编译过程：编译+连接

## 计算机语言的分类

- 汇编语言

- 高级语言

- 脚本语言

## 分类

- 关键字

- 标识符

# 基本数据类型与运算

## 数据类型

- 基本数据类型：整型int，浮点型float，双精度浮点double，字符char，布尔bool

- 自定义数据类型：枚举类型，结构体类型，联合体类型，类类型

## 流程控制

- 条件判断：if,while,switch

## 数据的存储与操作

每个数据都会单独分配内存空间来处理

CPU只是对内存数据进行操作，而不会区分不同的数据类型。区分数据类型并选择不同的操作，是编译器需要完成的工作。

# 函数 Function

参数表和函数体。

## 参数传递

函数在调用时才分配存储单元

### 值传递

语法规定：传递给函数的实参，与函数形参表中的数据类型一致

函数实例：

```cpp
//函数声明，此处省略函数定义
void swap(int a, int b);

int main(){
    int a, b;
    swap(a, b);    //函数引用，因为传递的是值，此处a, b没有被交换

    return 0;
}
```

### 引用传递

语法规定：使用“&”符号定义一个引用，引用必须指向已经存在的对象。函数的形参是一个引用，传递给函数的实参是被引用对象

```cpp
int i;
int& ri = i;    //ri是i的一个引用
```

函数实例：

```cpp
//函数声明，此处省略函数定义
void swap(int& a, int& b);

int main(){
    int a, b;
    swap(a ,b);    //函数引用，因为传递的是引用，此处a, b被交换

    return 0;
}
```

### 指针传递

语法定义：传递实参的地址给子函数，子函数的形参表中定义形参为指针类型

程序实例：

```cpp
//函数声明，此处省略函数定义
void swap(int* a, int* b);

int main(){
    int a, b;
    swap(&a, &b);    //函数引用，传递指针给子函数
    return 0;
}
```

## 函数的调用

### 运行栈

最后调用的函数总是最先返回，因此可以用栈这种数据结构来保存。运行栈就是专为函数调用设计的数据结构，

### 指针

寄存器中通常会保存两个指针，分别指向栈顶和函数调用发生的位置，来进行函数的调用和返回。

- **栈顶指针**：指向栈顶的地址

- **帧指针**：指向函数调用时的地址

## 函数的声明与安全性

C++ 要求函数在使用时先声明返回值类型和参数表，这样可以在编译过程中发现错误，是设计更为合理的编程语言。如果不做声明，在参数传递和参数返回两个过程中，都可能发生错误。
- 参数传递中，有可能把参数类型传错，将整型变量传递给浮点变量，而不做类型转换。
- 参数返回中，不做声明，有可能用整型方法去获取void类型的函数值，就会读取垃圾数据。

# 类与对象 Class & Object

## 构造函数与析构函数 Constructor and Destructor

- **初始化列表**：在参数表和函数体之间，构造还可以拥有初始化列表，效率比在函数体中赋值要高一些。因为当传递参数是类时，在初始化列表中进行初始化，只需要执行一次复制构造函数。

- **委托构造函数**：代码的一致性

- **复制构造函数**：函数名与类名一致，形参表为const定义的类对象。可以用"=delete"指令隐藏构造函数。有两个要点：复制和构造。

- **析构函数**：

## 组合类

- **组合类的构造函数**：初始化的顺序与类中声名的顺序相同，与初始化列表中的顺序不同，组合类初始化时，会调用两次初始化构造函数，第一次是将实参赋值给形参，第二次是把形参值赋值给组合类中的对象。

- **前向引用声名**：只声名类的名字而不包含任何细节。

## UML

- 事物：

- 关系：依赖，重数，聚集（组合），泛化

- 图：

## 特殊类

- 结构体：在C++中是特殊的类，成员默认是public

- 联合体：成员共用存储空间，只有一个成员有效，可以使用无名的联合体。

- 枚举类：类型控制更严格，无法比较不同类的枚举类型；作用域限制在类中，可以使用同样的名字。



# 数据的共享与保护

## 作用域

作用域由小到大可以分为以下几种：

- 函数原型作用域：只在形参表中存在

- 局部作用域：又称为块作用域，变量定义所在的最小的一对大括号内

- 类作用域：

- 文件作用域：又称为静态作用域

- 命名空间作用域：

## 可见性

作用域和可见性可能不一致：当内层作用域与外层作用域出现变量重名

## 生存期

- 静态生存期：文件作用域中定义的变量，或用static声明的变量，初始化只进行一次

- 动态生存期：与作用域一致，同时消亡

## 类的静态对象

- 为所有类共有

- 声明在类体重，初始化和定义在类体之外

- 静态函数：无法确定调用对象，不可直接访问对象的非静态变量

## 友元: freind

- 友元函数：在类中声明，在类外定义，需要把对象当做实参传递给函数

- 友元类：友元关系式单向的

## 常类型：const

- 常对象：必须初始化，不能被更新

- 常成员：

	a. 常数据成员
	
	b. 常函数成员（一种函数重载的判断条件）：承诺不改变数据状态，并由编译器进行检验

- 常引用：提高参数传递效率的同时，满足安全性的条件

- 常指针

## 多文件结构

C++工程结构：声明文件、定义文件、使用文件

- 外部变量：文件作用域中定义的变量，默认都是外部变量。使用时需要用extern关键字声明之后，才可以使用

- 外部函数：

- 编译预处理：#include, #define, #if #endif #else #elif, #ifdef

## 标准C++库

- 输入输出类iostream：

- 容器类与抽象数据类型stl：

- 存储管理类

- 算法algorithms：

- 错误处理

- 运行环境支持


# 指针和数组 Pointers & Array

&: 取数据对应的地址，*: 取地址对应的数据

## 指针的应用场景

- 动态内存分配，返回值只能是指针

- 深拷贝：自定义构造函数，为类内的指针属性申请内存空间。

## 指针

- 定义：用于存放地址类型的变量

- 初始化：指针变量的赋值必须是合法获得的地址,不可用非静态变量去初始化静态指针，空指针：nullptr

- 指向常量的指针，指针类型的常量

- 指针的算术运算：+n指向第n个数据的起始位置

- 指针的关系运算：指向相同类型的指针可以进行关系运算，也可以跟0进行关系运算

## 数组

- 定义：类型说明符 数组名[常量表达式][常量表达式]

- 初始化：可以只给一部分元素初始值，数组名保存首元素的内存地址，为常量

- 传递：数组作为函数参数传递时，直接传递指针

- 指针数组：

## 函数与指针

### 指针类型的函数

返回值为指针。 不能把局部地址返回给主调函数

### 指向函数的指针
、
用于函数回调

## 对象与指针

- 使用语法：Point* ptr;ptr->getx();

- this指针：类对象隐含的指针

## 动态内存分配

- 使用语法：new 类型名T（初始化参数列表）；delete 指针标识符；delet[] 数组标识符

- 注意事项：分配和释放一定要配合使用

## 智能指针

- unique_ptr ：不允许多个指针共享资源，可以用标准库中的move函数转移指针

- shared_ptr ：多个指针共享资源

- weak_ptr ：可复制shared_ptr，但其构造或者释放对资源不产生影响

## 对象的复制与移动

### 复制

- 浅层复制：数据成员的一一对应

- 深层复制：指针指向的动态内存空间

### 移动构造

将原始值赋值为nullptr


## 字符串

- C风格字符串：字符串数组

- C++风格：string 类